# 状态管理与数据持久化

## 状态分类与设计理念

xhMonitor系统采用多层次状态管理架构,根据状态的生命周期和访问模式将其划分为三个核心类别。这一分类体现了对不同数据特性的精准识别,确保每类状态都能获得与其特征相匹配的存储和管理方案。

应用级配置状态位于第一层,承载系统的持久化设置信息。该类状态通过ApplicationSettings实体(ApplicationSettings.cs:7-17)进行建模,采用Category-Key-Value三元组结构存储外观设置、数据采集参数、系统运行参数等配置项。设计者选择将配置值存储为JSON格式字符串,这一决策使得复杂类型(如数组、对象)的持久化无需额外序列化逻辑,同时为配置项的动态扩展提供了灵活性。值得注意的是,系统在数据库层面通过(Category, Key)复合唯一索引(MonitorDbContext.cs:69)确保配置项的唯一性,避免了逻辑层的重复性校验负担。

会话级状态构成第二层,涵盖实时性能指标与用户交互状态。桌面端FloatingWindowViewModel(FloatingWindowViewModel.cs:15-89)管理着三个进程集合(TopProcesses、PinnedProcesses、AllProcesses)以及面板状态机(Collapsed → Expanded → Locked → Clickthrough),这些状态随用户操作和数据推送持续变化。Web端则通过React Hooks机制维护metricsData和metricHistory状态(App.tsx:20-32),后者保留最近30个数据点以支持趋势图渲染。此类状态的共同特征是生命周期与会话绑定,应用关闭后自然失效,因此系统未为其设计持久化机制,体现了对资源的合理利用。

持久化度量数据占据第三层,服务于历史查询与趋势分析场景。系统通过ProcessMetricRecord和AggregatedMetricRecord两个实体(MonitorDbContext.cs:16-17)分别存储原始采集记录和聚合统计数据。原始记录包含进程级CPU、内存、GPU等指标的JSON序列化字典(MetricRepository.cs:24-32),聚合记录则按时间粒度汇总系统级指标。这一分层存储设计使得实时查询可直接访问聚合表获得秒级响应,而深度分析则可下钻至原始记录进行细粒度追溯,在查询性能与数据完整性之间达成平衡。

## 状态存储架构

状态的物理存储采用数据库与文件系统双轨并行的混合架构,两者在职责划分上呈现明显差异。SQLite数据库承担结构化数据的持久化职责,Entity Framework Core在其上层提供对象关系映射能力。系统在启动阶段通过DbContextFactory(Program.cs:28-30)注册数据库上下文工厂,这一设计源于ASP.NET Core后台服务的多线程并发特性。DbContext本身非线程安全,工厂模式确保每个数据库操作获得独立的上下文实例,从而避免并发访问导致的状态污染。

数据库层启用了WAL(Write-Ahead Logging)日志模式(MonitorDbContext.cs:13),这一SQLite特性允许读写操作并发执行,显著提升了高频数据采集场景下的吞吐能力。在传统的回滚日志模式下,写操作会阻塞所有读请求,而WAL模式通过将变更先写入独立日志文件,使读事务仍可访问数据文件的一致性快照。这一优化对于每秒采集系统指标的Monitor Worker尤为关键,确保数据持久化不会影响实时查询的响应时延。

文件系统存储则专注于半结构化配置数据的管理。WidgetSettings(WidgetSettings.cs:5-8)采用JSON文件(data/widget-settings.json)进行持久化,WidgetConfigController直接通过File.WriteAllText和File.ReadAllText完成读写操作(WidgetConfigController.cs:34-39、25-27)。这一设计回避了将动态配置纳入数据库的复杂性,特别是MetricClickActions字典包含任意数量的度量项配置,若采用关系型表结构则需引入额外的关联表,增加查询复杂度。文件方案通过序列化整个对象树,使得配置的读取和更新均为原子操作,简化了并发控制逻辑。

内存状态的存储依赖于各层的状态容器机制。桌面端ViewModels通过ObservableCollection<T>(FloatingWindowViewModel.cs:22-24)存储进程列表,该集合类型实现INotifyCollectionChanged接口,当集合内容变化时自动触发UI绑定更新,是WPF数据绑定机制的基础设施。Web端React组件通过useState钩子(App.tsx:20)创建状态变量,状态更新触发组件重渲染,实现声明式UI的数据驱动范式。两种机制虽然技术栈迥异,但均遵循单向数据流原则,状态变更通过明确的setter方法进行,避免了直接修改状态引发的追踪失效问题。

## 状态同步机制

系统采用推拉结合的混合同步策略,根据数据的实时性要求选择不同的传输通道。实时性能指标通过SignalR推送通道进行分发,后端MonitorWorker每秒采集系统指标后,通过IHubContext<MetricsHub>.Clients.All.SendAsync(Program.cs中注入)将数据广播至所有连接客户端。桌面端FloatingWindowViewModel在构造时建立SignalR连接并注册事件处理器(FloatingWindowViewModel.cs:141-146),当接收到'metrics.latest'事件时,通过Dispatcher.Invoke将数据更新封送至UI线程(FloatingWindowViewModel.cs:148-160)。这一跨线程调度机制是WPF单线程UI模型的必然要求,SignalR回调运行于后台线程池,直接更新ObservableCollection将触发跨线程访问异常,Dispatcher确保所有UI操作在UI线程上顺序执行。

Web端采用相似的SignalR连接机制(useMetricsHub.ts:12-20),但同步策略存在显著差异。React的状态更新本质上是调度reconciliation过程,setState调用可在任意线程安全执行,框架内部通过消息队列机制确保状态变更的线性化。因此useMetricsHub钩子直接在SignalR回调中调用setMetricsData(useMetricsHub.ts:23),无需显式线程调度。这一差异反映了WPF与React在并发模型上的本质区别:前者通过消息泵实现单线程事件循环,后者则依赖不可变数据结构支持并发安全的状态更新。

配置数据的同步采用基于HTTP REST API的拉取模式,体现了对数据一致性与网络效率的综合考量。SettingsViewModel通过HttpClient发起GET请求(SettingsViewModel.cs:108)从ConfigController加载配置,返回的JSON自动反序列化为嵌套字典结构(SettingsViewModel.cs:111)。更新配置时,ViewModel将所有设置序列化后通过PUT请求提交(SettingsViewModel.cs:174),后端Controller遍历字典条目逐一更新数据库记录(ConfigController.cs:240-258)。这一批量更新策略减少了网络往返次数,同时通过单一事务确保多配置项更新的原子性,避免部分更新导致的配置不一致状态。

跨模块的状态共享通过依赖注入容器进行协调。MetricRepository作为单例服务(Program.cs:32)被注入至MonitorWorker和QueryController,前者写入实时指标,后者读取历史数据。Repository内部通过DbContextFactory按需创建DbContext实例(MetricRepository.cs:18、23),每个数据库操作在独立的上下文中执行,操作完成后上下文随await using作用域结束自动释放。这一模式确保了并发安全性,代价是无法跨操作复用DbContext的一级缓存,但在高频写入的监控场景下,缓存命中率本就有限,牺牲可接受。

## 持久化策略与恢复机制

数据库持久化遵循Entity Framework Core的变更跟踪机制,开发者操作实体对象,框架自动生成SQL语句完成持久化。ConfigController更新设置时,通过FirstOrDefaultAsync查询现有记录(ConfigController.cs:248),修改实体属性后调用SaveChangesAsync(ConfigController.cs:260),EF Core的ChangeTracker检测到属性变更,生成对应的UPDATE语句执行。这一抽象层屏蔽了SQL细节,使业务逻辑聚焦于领域对象操作,同时通过参数化查询防范SQL注入风险。

数据库迁移采用Code-First策略,架构定义存在于C#实体类与DbContext配置中,通过dotnet ef migrations命令生成迁移脚本。应用启动时自动执行dbContext.Database.Migrate()(Program.cs:51-54),确保数据库架构与代码模型同步。这一自动化流程消除了手动执行SQL脚本的运维负担,特别适用于桌面应用的分发场景,用户首次运行时自动完成数据库初始化。迁移机制还支持架构演进,新增实体或列时,框架生成增量ALTER TABLE语句,保留现有数据,实现无损升级。

种子数据通过HasData方法预置于迁移中(MonitorDbContext.cs:75-91),包含10项默认配置和4个告警阈值规则。这一设计确保应用初始化后即具备可用的默认设置,避免空配置导致的功能异常。种子数据的CreatedAt和UpdatedAt统一设为固定时间戳(seedTimestamp),使得每次迁移生成的数据库状态具有可预测性,便于自动化测试验证初始状态的正确性。

JSON文件持久化采用同步写入策略(WidgetConfigController.cs:38),File.WriteAllText阻塞至数据完整写入磁盘。这一简单粗暴的方式在配置文件小于10KB的场景下性能可接受,且避免了异步写入的复杂性。然而该方案存在原子性隐患:写入过程中应用崩溃将导致文件损坏,恢复时读取失败。改进方案可采用写-重命名模式,先写入临时文件,完成后原子性地替换目标文件,确保任意时刻文件均处于一致性状态。当前实现未包含此保障,体现了快速迭代阶段对可靠性的妥协。

错误恢复机制在数据库层相对完善,EF Core的事务支持确保SaveChangesAsync失败时所有变更自动回滚(ConfigController.cs:260),数据库不会残留不一致状态。HTTP API层通过try-catch捕获异常并返回503状态码(ConfigController.cs:156-165),客户端可根据错误码实施重试策略。然而SettingsViewModel的SaveSettingsAsync仅通过Debug.WriteLine记录异常(SettingsViewModel.cs:181),未向用户展示错误提示,可能导致静默失败后用户误认为设置已保存。完善的实现应通过消息框或状态栏通知用户保存结果,并提供重试入口。

状态恢复依赖于各层的初始化逻辑。桌面端FloatingWindowViewModel在构造时自动建立SignalR连接(FloatingWindowViewModel.cs:137),连接成功后开始接收实时数据流,无需显式加载历史状态。SettingsViewModel则通过显式调用LoadSettingsAsync(SettingsViewModel.cs:104)从API拉取配置,该方法需在窗口加载事件中手动触发。Web端useMetricsHub钩子通过useEffect在组件挂载时启动连接(useMetricsHub.ts:21-35),连接断开时自动重连(withAutomaticReconnect),确保网络抖动后状态流恢复。这些机制共同保证了应用重启或网络恢复后,状态能够自动同步至最新快照,用户无需手动刷新。
