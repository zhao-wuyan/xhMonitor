# 设计模式与架构风格

## 架构风格概览

xhMonitor采用分层模块化架构,整体设计围绕关注点分离和可扩展性展开。从系统拓扑结构审视,项目可划分为三个核心层次:核心领域层(XhMonitor.Core)、服务层(XhMonitor.Service)、表现层(XhMonitor.Desktop),各层职责明确且边界清晰。这一架构特征确保了模块的独立可测试性,同时为后续功能扩展奠定了坚实基础。

核心领域层作为系统的基石,封装了所有业务无关的技术抽象,包括指标提供者接口(`IMetricProvider`)、仓储接口(`IProcessMetricRepository`)以及各类数据实体。该层通过接口定义建立稳定的契约,使得上层服务可以灵活替换底层实现而不影响业务逻辑。服务层位于架构中间位置,承担数据采集、聚合计算、实时推送等核心业务职责,通过依赖注入获取底层能力,体现了依赖倒置原则的应用。表现层则专注于用户交互体验,采用WPF技术栈实现桌面客户端,通过MVVM模式实现视图与业务逻辑的解耦。

从技术选型角度分析,系统采用ASP.NET Core作为服务端框架,结合Entity Framework Core实现数据持久化,使用SignalR实现服务端与客户端的实时双向通信。这一技术组合体现了现代.NET生态的最佳实践,为系统的高性能和可维护性提供了有力保障。

## 创建型模式应用

### 工厂方法模式

系统在数据库上下文管理中应用了工厂方法模式,通过`IDbContextFactory<MonitorDbContext>`接口实现数据库上下文的按需创建。这一设计源于对多线程环境下资源安全性的考量。在`AggregationWorker.cs:11-27`的实现中,后台工作服务通过构造函数注入工厂实例,在需要时调用`CreateDbContextAsync`方法创建新的上下文对象。相较于共享单一上下文实例,这一模式有效避免了并发访问冲突,确保每个聚合任务在独立的事务边界内执行。

具体实现位于`Program.cs:69-74`,系统在服务配置阶段通过`AddDbContextFactory`扩展方法注册工厂。值得注意的是,工厂模式在此场景的应用并非简单的对象创建封装,而是结合了异步生命周期管理和资源释放策略。每个通过工厂创建的上下文均实现了`IAsyncDisposable`接口,在`await using`语法支持下实现自动资源清理,体现了工厂模式与现代C#语言特性的深度整合。

### 建造者模式

SignalR连接的构建过程采用了建造者模式,通过`HubConnectionBuilder`类提供流式API来配置连接参数。在`SignalRService.cs:39-42`的实现中,系统通过链式调用`WithUrl`、`WithAutomaticReconnect`等方法逐步构建连接对象,最终调用`Build`方法完成实例化。这一设计使得连接配置过程具备良好的可读性和扩展性,新增配置选项时无需修改构造函数签名,体现了开闭原则的应用。

建造者模式在此场景的价值在于隔离了复杂对象的构建逻辑与表示逻辑。SignalR连接涉及URL端点、重连策略、序列化配置等多个维度的参数,若采用传统构造函数注入将导致参数列表冗长且难以维护。通过建造者模式,每个配置步骤对应独立的方法调用,使得构建过程自文档化,同时为未来集成认证、消息压缩等高级特性预留了扩展空间。

### 单例模式的变体

系统在指标提供者注册表(`MetricProviderRegistry`)的生命周期管理中应用了单例模式的变体。在`Program.cs:82-96`的配置中,通过`AddSingleton`方法将注册表注册为单例服务,确保整个应用生命周期内仅存在一个注册表实例。这一设计源于对指标提供者状态一致性的要求,多个服务组件需要共享同一个提供者集合,避免重复初始化底层性能计数器导致资源浪费。

不同于经典GoF单例模式通过静态字段和私有构造函数实现,本系统采用依赖注入容器管理单例生命周期,使得单例对象的创建和依赖解析由框架统一调度。`MetricProviderRegistry.cs:8-28`的构造函数接受`ILogger`和`ILoggerFactory`等依赖参数,这些依赖同样由容器注入,体现了控制反转的应用。这一变体解决了传统单例模式难以测试和依赖管理困难的痛点,同时保留了全局唯一性保证。

### 插件化工厂

指标提供者的动态加载机制体现了插件化工厂模式的应用。在`MetricProviderRegistry.cs:110-127`的实现中,系统通过扫描指定目录下的DLL文件,使用反射API动态加载程序集并实例化实现了`IMetricProvider`接口的类型。这一设计使得系统支持第三方扩展,开发者可通过实现标准接口并部署至插件目录的方式新增指标采集能力,无需修改核心代码。

从实现细节分析,插件加载过程包含类型发现(`Assembly.GetTypes`)、接口匹配(`IsAssignableFrom`)、实例创建(`Activator.CreateInstance`)三个阶段,并在每个阶段设置异常捕获和日志记录,确保单个插件加载失败不影响整体系统运行。`MetricProviderRegistry.cs:162-216`的错误处理策略体现了防御性编程思想,通过捕获`ReflectionTypeLoadException`、`MissingMethodException`等特定异常类型,系统能够提供精准的诊断信息,降低插件开发者的调试成本。

## 结构型模式应用

### 适配器模式

系统在VRAM指标采集中隐含应用了适配器模式,将Windows性能计数器API适配为统一的`IMetricProvider`接口。在`SystemMetricProvider.cs:130-138`的实现中,系统优先使用"GPU Adapter Memory"性能计数器类别获取显存数据,这一Windows系统API返回的是`PerformanceCounter`对象,与业务层期望的`MetricValue`类型存在阻抗不匹配。通过在具体提供者类中封装类型转换和单位换算逻辑,系统实现了异构接口的透明集成。

适配器模式在此场景的价值在于隔离平台相关代码。Windows性能计数器、WMI查询等底层API具有强平台依赖性,直接在业务逻辑中调用将导致跨平台移植困难。通过将这些API封装在实现`IMetricProvider`接口的适配器类中,上层服务仅依赖抽象接口,为未来支持Linux(通过读取`/proc`文件系统)或macOS(通过调用`sysctl`系统调用)预留了扩展空间。

### 仓储模式

数据持久化层应用了经典的仓储模式,通过`IProcessMetricRepository`接口抽象数据访问逻辑。在`MetricRepository.cs:10-78`的实现中,仓储类封装了Entity Framework Core的具体操作,向上层提供`SaveMetricsAsync`等业务友好的方法签名。这一设计使得业务层无需感知底层使用的是关系型数据库还是NoSQL存储,实现了数据访问逻辑与业务逻辑的解耦。

仓储模式的应用体现了领域驱动设计(DDD)的核心思想。在`Worker.cs:15-25`中,后台工作服务通过构造函数注入`IProcessMetricRepository`接口,所有数据持久化操作均通过仓储方法完成,避免直接操作`DbContext`。这一约束确保了数据访问逻辑的集中管理,便于实施统一的事务控制、缓存策略和性能优化。从测试角度分析,仓储接口的存在使得业务逻辑可通过Mock对象进行单元测试,无需依赖真实数据库环境。

### 外观模式

`SystemMetricProvider`类体现了外观模式的应用,为客户端提供了统一的系统级指标访问接口。在`SystemMetricProvider.cs:12-34`的设计中,该类聚合了CPU、GPU、Memory、VRAM四个独立的指标提供者,并通过`GetSystemUsageAsync`、`GetHardwareLimitsAsync`等高层方法封装复杂的指标采集和聚合逻辑。客户端调用时无需关心底层涉及多个提供者的协同工作,通过单一入口即可获取完整的系统状态快照。

外观模式在此场景的价值在于简化客户端代码。若无该外观类,`Worker.cs`等服务组件需分别注入四个独立的提供者接口,并手动编排异步调用顺序和结果聚合逻辑,导致代码重复和维护困难。通过外观类封装这些复杂性,系统将"如何获取各项指标"的技术细节下沉,使得业务层代码可聚焦于"何时采集"和"如何响应"等核心关注点。`SystemMetricProvider.cs:76-90`的实现使用`Task.WhenAll`并行执行多个异步调用,这一性能优化对客户端完全透明,体现了外观模式的封装价值。

## 行为型模式应用

### 观察者模式

系统在实时数据推送机制中深度应用了观察者模式,通过事件驱动架构实现组件间的松耦合通信。在`SignalRService.cs:14-18`的设计中,服务类定义了`MetricsReceived`、`ConnectionStateChanged`等多个事件,允许订阅者注册回调函数以响应特定状态变化。`FloatingWindowViewModel.cs:94-99`展示了订阅过程,视图模型在初始化阶段通过`+=`运算符绑定事件处理器,当SignalR连接接收到新数据时,相应处理器被自动调用,无需视图模型主动轮询。

观察者模式在此场景的应用体现了"好莱坞原则"(Don't call us, we'll call you)。SignalR服务作为主题(Subject)负责监听服务端推送,多个视图模型作为观察者(Observer)注册兴趣点,当数据到达时由主题通知所有观察者。这一设计避免了观察者与主题间的强依赖关系,新增订阅者时无需修改主题代码,体现了开闭原则。`SignalRService.cs:98-114`的连接状态事件处理进一步展示了观察者模式的灵活性,系统通过注册`Reconnecting`、`Reconnected`、`Closed`等生命周期事件,实现了细粒度的状态感知。

### 模板方法模式

后台工作服务的实现采用了模板方法模式,通过继承`BackgroundService`抽象类并重写`ExecuteAsync`方法定义具体执行逻辑。在`AggregationWorker.cs:29-48`的实现中,框架定义了后台服务的启动、执行、停止等生命周期骨架,子类仅需实现`ExecuteAsync`方法填充具体业务逻辑。这一设计使得开发者无需关心线程管理、取消令牌传播等基础设施代码,可专注于业务流程的编排。

模板方法模式在此场景的价值在于标准化扩展点。`BackgroundService`基类封装了`StartAsync`、`StopAsync`等公共方法,并在内部调用抽象的`ExecuteAsync`方法,确保所有后台服务遵循统一的生命周期契约。从`DatabaseCleanupWorker.cs:6`和`Worker.cs:11`的实现可以看出,系统存在多个后台服务,它们均继承同一基类并实现相同接口,这一一致性简化了服务的注册、启动和监控,体现了框架设计的内聚性。

### 策略模式的潜在应用

虽然当前代码库未显式实现策略模式,但`IMetricProvider`接口的设计为未来应用该模式预留了空间。在`MetricProviderRegistry.cs:30-41`的实现中,系统根据`metricId`动态选择具体的指标提供者实例,这一运行时策略选择机制与策略模式的核心思想一致。若未来需要支持同一指标的多种采集策略(如CPU使用率可通过性能计数器或WMI获取),可通过实现多个`IMetricProvider`并在注册表中根据配置参数选择具体策略,而无需修改客户端代码。

从架构演进角度分析,当前系统通过接口抽象实现了策略的可替换性,但策略选择逻辑相对静态(在启动阶段通过插件加载确定)。若引入配置驱动的策略切换机制,可进一步提升系统灵活性。例如,在低性能设备上自动降级至轻量级采集策略,在高端工作站上启用高精度监控,这一动态调整能力正是策略模式擅长解决的问题。

### 命令模式的隐含应用

WPF的命令绑定机制体现了命令模式的应用,虽然当前代码库未显式实现`ICommand`接口,但从`FloatingWindow.xaml.cs:43-44`定义的事件参数类可以推断出系统支持用户操作的参数化传递。`MetricActionEventArgs`和`ProcessActionEventArgs`封装了用户交互意图(如对某个进程执行特定操作),这些事件参数在MVVM架构中扮演命令对象的角色,承载操作类型、目标对象等上下文信息。

命令模式在UI层的应用价值在于解耦触发者与执行者。用户在视图中点击按钮触发操作,视图通过事件将命令对象传递给视图模型,视图模型根据命令类型决定具体执行逻辑。这一间接性使得同一命令可被多个视图元素触发(如工具栏按钮和上下文菜单),也便于实现操作的撤销/重做、批处理执行等高级特性。虽然当前实现较为简化,但其架构设计已为未来扩展命令队列、宏录制等功能奠定了基础。

## MVVM架构模式

### 数据绑定与通知机制

系统采用标准MVVM模式实现WPF客户端,通过`INotifyPropertyChanged`接口建立视图与视图模型间的双向数据绑定。在`FloatingWindowViewModel.cs:11-90`的实现中,所有可观察属性均通过`OnPropertyChanged`方法触发变更通知,确保视图能自动响应数据更新。这一设计使得视图代码(XAML)可专注于布局和样式定义,无需包含数据获取和状态管理逻辑,实现了关注点分离。

数据绑定机制的深度应用体现在`ProcessRowViewModel.cs:370-429`的嵌套视图模型设计中。每个进程行封装为独立的视图模型,拥有独立的属性变更通知机制。当`FloatingWindowViewModel`更新进程列表时,通过`ObservableCollection`的集合变更通知自动触发视图的列表项增删,而单个进程的指标更新则通过嵌套视图模型的属性通知触发局部刷新。这一分层通知机制避免了全量列表重绘,显著提升了UI性能,体现了MVVM模式对复杂交互场景的良好支持。

### 视图模型的职责边界

视图模型在MVVM架构中扮演视图与模型间的适配器角色,其职责边界的清晰界定是架构成功的关键。在`FloatingWindowViewModel.cs:94-99`的构造过程中,视图模型主动创建并持有`SignalRService`实例,负责订阅服务事件并将接收到的DTO对象转换为视图友好的属性。这一设计将网络通信细节隔离在服务层,视图模型仅处理数据转换和状态管理,避免视图直接依赖SignalR等基础设施组件。

值得注意的是,视图模型的生命周期管理体现了对资源清理的重视。`FloatingWindowViewModel.cs:353-361`实现了`CleanupAsync`方法,在视图关闭时取消事件订阅并断开SignalR连接,避免内存泄漏和悬挂引用。这一显式清理机制补充了.NET垃圾回收的不足,对于持有非托管资源(如网络连接)的对象尤为重要。从架构角度分析,这一设计体现了MVVM模式与资源管理模式(如Dispose模式)的协同应用。

### 状态机模式的融合

浮动窗口的面板状态管理融合了状态机模式,通过枚举类型和状态转换方法实现复杂交互逻辑。在`FloatingWindowViewModel.cs:22-140`的实现中,系统定义了`Collapsed`、`Expanded`、`Locked`、`Clickthrough`四种状态,并通过`OnBarPointerEnter`、`OnBarClick`等方法控制状态转换。这一设计将UI状态的合法转换路径显式化,避免了散乱的布尔标志位导致的状态混乱。

状态机的应用体现了声明式编程思想。`FloatingWindowViewModel.cs:102-127`的状态转换逻辑通过`if-else`分支明确定义了每个状态下允许的操作和目标状态,这一代码结构与状态转换图一一对应,具备良好的自文档性。相较于命令式的状态管理(通过散布在各处的赋值语句),状态机模式将状态转换逻辑集中管理,便于理解、测试和扩展。`EnterClickthrough`和`ExitClickthrough`方法的对称设计进一步展示了状态机的可逆性,体现了对用户体验的细致考量。

## 并发与异步模式

### 工厂模式与并发安全

系统在多线程环境下的数据库访问采用了工厂模式结合异步上下文管理,实现线程安全的资源使用。在`AggregationWorker.cs:63`的实现中,每次数据库操作均通过`IDbContextFactory<MonitorDbContext>`创建新的上下文实例,并使用`await using`语法确保异步释放。这一模式避免了多个后台服务共享单一DbContext导致的并发冲突,每个聚合任务在独立的事务边界内执行,互不干扰。

从性能角度分析,频繁创建和销毁DbContext实例可能引发性能担忧,但Entity Framework Core的连接池机制有效缓解了这一问题。底层数据库连接被池化复用,上下文对象的轻量级设计使得创建开销可控。`DatabaseCleanupWorker.cs:51`和`AggregationWorker.cs:179`等多处应用相同模式,体现了系统在并发安全与性能间的平衡考量。这一架构选择符合.NET Core最佳实践,为后续支持更高并发度的场景奠定了基础。

### 异步事件处理

系统在事件驱动架构中融入异步编程模式,通过`async`/`await`关键字实现非阻塞的事件处理。在`FloatingWindowViewModel.cs:156-160`的连接状态变更处理中,系统使用`Dispatcher.Invoke`将跨线程调用封送到UI线程,避免直接从后台线程更新UI属性导致的线程安全问题。这一模式体现了对WPF线程模型的深刻理解,确保所有UI更新均在主线程执行,同时保持异步处理的性能优势。

异步事件处理的复杂性在于异常传播和取消令牌管理。`FloatingWindowViewModel.cs:158`的Dispatcher检查通过验证`HasShutdownStarted`属性避免在应用关闭阶段执行UI更新,这一防御性编程体现了对边缘情况的周全考虑。从架构角度分析,事件回调与UI线程的解耦使得系统可在后台线程处理计算密集型任务,仅在最终呈现阶段切换至主线程,最大化并发执行效率。

## 依赖注入与控制反转

### 构造函数注入

系统全面采用依赖注入模式管理组件依赖关系,通过构造函数注入实现依赖的显式声明和外部化配置。在`MetricRepository.cs:21-27`的实现中,仓储类通过构造函数接收`IDbContextFactory`和`ILogger`等依赖,由ASP.NET Core的内置容器在运行时解析并注入。这一设计使得依赖关系一目了然,便于理解组件间的耦合关系,同时为单元测试提供了Mock注入点。

构造函数注入的应用体现了显式依赖原则(Explicit Dependencies Principle)。所有外部依赖均通过构造函数参数声明,避免了在方法内部通过服务定位器(Service Locator)或静态访问器获取依赖的反模式。`AggregationWorker.cs:21-27`和`MetricProviderRegistry.cs:15-23`等多处遵循相同模式,使得系统的依赖图可通过静态分析工具自动生成,便于识别循环依赖和过度耦合等架构问题。

### 生命周期管理

依赖注入容器的生命周期管理策略直接影响系统的资源使用和性能特征。在`Program.cs:76-110`的服务注册中,系统针对不同组件应用了差异化的生命周期策略:`IProcessMetricRepository`注册为单例,`IDbContextFactory`注册为单例,而`DbContext`通过工厂按需创建为短暂(Transient)实例。这一混合策略平衡了资源复用与线程安全的需求,单例服务避免重复初始化开销,短暂实例确保多线程环境下的隔离性。

生命周期管理的复杂性在于处理跨作用域的依赖关系。`MetricProviderRegistry`作为单例持有多个`IMetricProvider`实例,这些提供者同样需在整个应用生命周期内保持活跃以维持性能计数器的预热状态。`MetricProviderRegistry.cs:218-241`的`Dispose`方法确保在应用关闭时正确释放所有提供者资源,体现了对象生命周期与容器生命周期的协同管理。这一设计避免了资源泄漏,同时保证了提供者的单例语义。

## 架构演进建议

从当前设计模式应用情况分析,系统架构展现了良好的可扩展性和可维护性,但仍存在进一步优化空间。在创建型模式方面,可考虑引入抽象工厂模式以支持多数据库后端切换,将当前SQLite专用的实现泛化为可配置的存储策略。在结构型模式方面,随着指标类型增多,可引入装饰器模式实现指标数据的缓存、限流等横切关注点,避免在每个提供者中重复实现相同逻辑。

在行为型模式方面,当前基于事件的观察者模式可进一步演进为响应式编程(Reactive Extensions),通过`IObservable<T>`接口实现更强大的数据流组合和转换能力。对于后台工作服务,可引入责任链模式实现聚合管道的可配置化,使得分钟级、小时级、日级聚合策略可通过配置文件动态调整。这些演进方向均基于现有架构的稳定接口,可采用渐进式重构策略逐步实施,确保系统在演进过程中保持向后兼容。
