{
  "project_structure": "Three-tier architecture: XhMonitor.Core (domain models, interfaces, providers), XhMonitor.Service (backend service with ProcessScanner, PerformanceMonitor, SignalR hub), XhMonitor.Desktop (WPF UI with MVVM pattern). Process monitoring follows a pipeline: ProcessScanner (Core/ProcessScanner.cs:23-65) -> PerformanceMonitor (Core/PerformanceMonitor.cs) -> SignalR broadcast -> Desktop ViewModel (ViewModels/FloatingWindowViewModel.cs:186-205). Plugin-based metric collection via IMetricProvider interface with MetricProviderRegistry (Service/Core/MetricProviderRegistry.cs:8-242).",
  "relevant_files": [
    {
      "path": "XhMonitor.Core/Models/ProcessInfo.cs",
      "relevance": 0.95,
      "rationale": "Core domain model containing ProcessName and CommandLine fields. This is where a new DisplayName or FriendlyName property should be added to maintain separation of concerns."
    },
    {
      "path": "XhMonitor.Service/Core/ProcessScanner.cs",
      "relevance": 0.90,
      "rationale": "Responsible for scanning processes and extracting CommandLine (line 75). This is where name extraction logic should be applied before creating ProcessInfo objects (line 101-107)."
    },
    {
      "path": "XhMonitor.Desktop/Models/ProcessInfoDto.cs",
      "relevance": 0.85,
      "rationale": "DTO for transferring process data to Desktop UI. Needs new field to carry friendly name from Service to Desktop."
    },
    {
      "path": "XhMonitor.Desktop/ViewModels/FloatingWindowViewModel.cs",
      "relevance": 0.80,
      "rationale": "ProcessRowViewModel (line 370-429) binds ProcessName to UI. Should display friendly name instead of raw process name. UpdateFrom method (line 411-419) needs to handle new field."
    },
    {
      "path": "XhMonitor.Core/Interop/ProcessCommandLineReader.cs",
      "relevance": 0.70,
      "rationale": "Provides CommandLine extraction via Windows API. The extracted CommandLine is the source data for name extraction patterns."
    },
    {
      "path": "XhMonitor.Service/appsettings.json",
      "relevance": 0.75,
      "rationale": "Configuration file with Monitor:Keywords section (line 13-16). Should be extended to support process-specific name extraction rules (e.g., regex patterns, argument positions)."
    },
    {
      "path": "XhMonitor.Core/Interfaces/IMetricProvider.cs",
      "relevance": 0.60,
      "rationale": "Plugin interface pattern example. If name extraction becomes complex, could follow similar pattern with IProcessNameExtractor interface for extensibility."
    },
    {
      "path": "XhMonitor.Service/Core/MetricProviderRegistry.cs",
      "relevance": 0.55,
      "rationale": "Registry pattern for plugin management. Could serve as reference if implementing ProcessNameExtractorRegistry for pluggable name extraction strategies."
    }
  ],
  "patterns": "**Plugin Architecture Pattern**: MetricProviderRegistry (Service/Core/MetricProviderRegistry.cs:8-242) demonstrates plugin-based extensibility with IMetricProvider interface, registration via RegisterProvider (line 49-92), and dynamic loading from assemblies (line 162-216). This pattern could be replicated for process name extraction strategies.\n\n**Provider Pattern**: CpuMetricProvider (Core/Providers/CpuMetricProvider.cs:9-230) shows provider implementation with MetricId, DisplayName, Unit properties and CollectAsync method. Similar pattern could be used for IProcessNameExtractor with ExtractorId, Priority, and Extract(commandLine) method.\n\n**MVVM Pattern**: FloatingWindowViewModel (Desktop/ViewModels/FloatingWindowViewModel.cs:11-430) uses INotifyPropertyChanged with ProcessRowViewModel nested class (line 370-429). ProcessName property (line 374-379) uses SetField helper for change notification. New FriendlyName property should follow same pattern.\n\n**DTO Pattern**: ProcessInfoDto (Desktop/Models/ProcessInfoDto.cs:5-18) uses JsonPropertyName attributes for serialization. ProcessInfo (Core/Models/ProcessInfo.cs:3-9) uses required init properties for immutability. New display name field should maintain this immutability pattern.\n\n**Configuration Pattern**: appsettings.json (Service/appsettings.json:13-16) uses nested sections (Monitor:Keywords). Name extraction rules should follow similar structure: Monitor:ProcessNameRules with process-specific patterns.\n\n**Parallel Processing Pattern**: ProcessScanner (Service/Core/ProcessScanner.cs:34-54) uses Parallel.ForEach with MaxDegreeOfParallelism=4 for concurrent process scanning. Name extraction should be thread-safe if integrated here.\n\n**Error Handling Pattern**: ProcessScanner catches specific exceptions (UnauthorizedAccessException, InvalidOperationException) and returns early (line 77-90). Name extraction should follow same defensive pattern with fallback to original ProcessName.",
  "dependencies": "**Internal Dependencies**:\n- XhMonitor.Core.Models.ProcessInfo: Domain model for process data\n- XhMonitor.Core.Interop.ProcessCommandLineReader: Windows API wrapper for CommandLine extraction\n- XhMonitor.Desktop.Models.ProcessInfoDto: Data transfer object for SignalR communication\n- System.Text.RegularExpressions: Required for regex-based name extraction from CommandLine\n\n**External Dependencies**:\n- System.Diagnostics.Process: Provides ProcessName property (used in ProcessScanner.cs:70)\n- System.Text.Json: Serialization for ProcessInfoDto (JsonPropertyName attributes)\n- Microsoft.Extensions.Configuration: For reading appsettings.json configuration\n- Microsoft.Extensions.Logging: For logging name extraction failures\n\n**No New NuGet Packages Required**: All necessary dependencies already present in project.",
  "integration_points": "**1. ProcessScanner.ProcessSingleProcess (Service/Core/ProcessScanner.cs:67-109)**\n   - Current: Creates ProcessInfo with raw processName (line 104)\n   - Integration: After line 75 (commandLine extraction), call name extractor: `string friendlyName = _nameExtractor.Extract(processName, commandLine);`\n   - Add to ProcessInfo creation (line 101-107): `FriendlyName = friendlyName`\n\n**2. ProcessInfo Model (Core/Models/ProcessInfo.cs:3-9)**\n   - Current: Has ProcessName, CommandLine properties\n   - Integration: Add new property: `public string? FriendlyName { get; init; }`\n   - Fallback logic: UI should display FriendlyName ?? ProcessName\n\n**3. ProcessInfoDto (Desktop/Models/ProcessInfoDto.cs:5-18)**\n   - Current: Transfers ProcessName to Desktop\n   - Integration: Add `[JsonPropertyName(\"friendlyName\")] public string FriendlyName { get; set; } = string.Empty;`\n\n**4. FloatingWindowViewModel.ProcessRowViewModel (Desktop/ViewModels/FloatingWindowViewModel.cs:370-429)**\n   - Current: Binds ProcessName to UI (line 374-379)\n   - Integration: Add FriendlyName property, modify UpdateFrom (line 411-419) to set FriendlyName from DTO\n   - UI Binding: Change XAML to bind to FriendlyName instead of ProcessName\n\n**5. Configuration (Service/appsettings.json:13-16)**\n   - Current: Monitor:Keywords array for process filtering\n   - Integration: Add Monitor:ProcessNameRules section with extraction patterns:\n   ```json\n   \"ProcessNameRules\": [\n     { \"ProcessName\": \"llama-server\", \"Pattern\": \"-m\\\\s+([^\\\\s]+)\", \"Group\": 1 },\n     { \"ProcessName\": \"python\", \"Pattern\": \"([^\\\\\\\\]+\\\\.py)\", \"Group\": 1 }\n   ]\n   ```\n\n**6. Worker.ExecuteAsync (Service/Worker.cs)**\n   - Current: Broadcasts ProcessName via SignalR\n   - Integration: Ensure FriendlyName is included in broadcast payload",
  "constraints": "**1. Performance Constraints**:\n   - ProcessScanner runs every 3 seconds (appsettings.json:14) with parallel processing (MaxDegreeOfParallelism=4)\n   - Name extraction MUST complete within milliseconds to avoid blocking process scanning\n   - Regex compilation should be cached to avoid repeated compilation overhead\n   - Avoid complex parsing logic that could slow down the scanning pipeline\n\n**2. Thread Safety**:\n   - ProcessScanner uses Parallel.ForEach (ProcessScanner.cs:39-54)\n   - Name extraction logic must be thread-safe or use thread-local state\n   - Configuration reading should be done once at startup, not per-process\n\n**3. Immutability Pattern**:\n   - ProcessInfo uses required init properties (ProcessInfo.cs:5-8)\n   - New FriendlyName property must follow same pattern: `public string? FriendlyName { get; init; }`\n   - Cannot modify after object creation\n\n**4. Backward Compatibility**:\n   - Existing database schema (ProcessMetricRecord, AggregatedMetricRecord) stores ProcessName\n   - FriendlyName should NOT be persisted to database (display-only concern)\n   - API responses must remain compatible with existing clients\n\n**5. Error Handling**:\n   - Name extraction failures must NOT crash process scanning\n   - Must fallback to original ProcessName if extraction fails\n   - Follow existing pattern: catch specific exceptions, log warnings, continue processing\n\n**6. Configuration Complexity**:\n   - Users may not understand regex patterns\n   - Need balance between flexibility (regex) and usability (simple templates)\n   - Consider providing preset rules for common processes (llama-server, python, node, etc.)\n\n**7. CommandLine Variability**:\n   - Different processes use different argument formats (--flag, -f, /flag)\n   - Argument order may vary\n   - Paths may contain spaces, requiring quote handling\n   - Some processes may not have relevant arguments in CommandLine\n\n**8. UI Constraints**:\n   - FloatingWindow has limited space for process names\n   - Long extracted names may need truncation or tooltip display\n   - Must maintain MVVM pattern with INotifyPropertyChanged",
  "clarification_needs": [
    {
      "question": "What approach should be used for defining name extraction rules?",
      "context": "Different processes have different CommandLine formats. For example, llama-server uses '-m model_name', Python uses 'python script.py', Node.js uses 'node app.js'. The system needs a flexible way to extract meaningful names from various formats. Three approaches are possible: (1) Regex patterns in configuration for maximum flexibility but requires user regex knowledge, (2) Predefined templates with placeholders like '{arg:--model}' for easier user configuration, (3) Hybrid approach with built-in rules for common processes and custom regex for advanced cases.",
      "options": [
        "Configuration-based regex patterns (Monitor:ProcessNameRules with regex per process type) - Maximum flexibility, requires regex knowledge",
        "Template-based extraction (e.g., '{arg:--model}', '{filename}') - User-friendly, limited flexibility",
        "Hybrid: Built-in rules for common processes (llama-server, python, node) + custom regex fallback - Best of both worlds",
        "Strategy pattern with IProcessNameExtractor interface - Plugin-based, most extensible but highest complexity"
      ],
      "recommended": 2
    },
    {
      "question": "Where should the name extraction logic be implemented?",
      "context": "Name extraction could be placed at different points in the pipeline. ProcessScanner.ProcessSingleProcess (line 67-109) is where CommandLine is first obtained. Alternatively, it could be a separate service injected into ProcessScanner, or a static utility class. The choice affects testability, maintainability, and adherence to SOLID principles.",
      "options": [
        "Inline in ProcessScanner.ProcessSingleProcess method - Simplest, but violates Single Responsibility Principle",
        "New ProcessNameExtractor service class injected into ProcessScanner - Clean separation, testable, follows existing provider pattern",
        "Static utility class ProcessNameHelper.Extract() - Simple, no DI needed, but harder to test and extend",
        "Extension method on ProcessInfo - Convenient, but extraction logic should happen before object creation"
      ],
      "recommended": 1
    },
    {
      "question": "How should the system handle extraction failures or missing rules?",
      "context": "Not all processes will have extraction rules defined, and regex patterns may fail to match. The system needs a fallback strategy. Current ProcessName (e.g., 'llama-server') could be kept, or a combination approach could be used (e.g., 'llama-server: model_name'). This affects user experience and debugging.",
      "options": [
        "Fallback to original ProcessName - Safe, always shows something, but defeats purpose for unconfigured processes",
        "Show 'ProcessName: ExtractedPart' format - Provides context, but may be verbose",
        "Show ExtractedPart only if successful, otherwise ProcessName - Clean, but inconsistent format",
        "Show ExtractedPart with fallback indicator (e.g., 'llama-server (no rule)') - Informative for debugging"
      ],
      "recommended": 2
    },
    {
      "question": "Should the friendly name be editable by users at runtime?",
      "context": "Users might want to manually override the extracted name for specific processes. This could be useful for processes where automatic extraction fails or for custom labeling. However, it adds complexity for persistence (where to store overrides?) and UI (how to edit?).",
      "options": [
        "No runtime editing - Keep it simple, rely on configuration rules only",
        "Allow editing via settings UI with persistence to appsettings.json - User-friendly but requires settings UI changes",
        "Allow editing via right-click context menu with in-memory persistence (lost on restart) - Quick fix without persistence complexity",
        "Allow editing with persistence to separate user-overrides.json file - Separates user customizations from app config"
      ],
      "recommended": 0
    }
  ],
  "_metadata": {
    "timestamp": "2026-01-13T00:00:00Z",
    "task_description": "当前进程监控名称显示对用户来说不够友好，比如llamacpp 运行了很多模型，我想让其能显示模型名称，名称在进程运行命令上，但是难点是，各种进程不同规则我如何能正确的提取名称呢，请你给出一些方案让我选择，请你结合当前项目架构进行考虑，且注意编程实践规范",
    "source": "cli-explore-agent",
    "exploration_angle": "patterns",
    "exploration_index": 1,
    "total_explorations": 3,
    "duration_seconds": 180
  }
}
