{
  "project_structure": "Three-tier architecture: XhMonitor.Core (domain models, interfaces, providers), XhMonitor.Service (backend service with ProcessScanner, SignalR hub, API controllers), XhMonitor.Desktop (WPF UI with ViewModels). Data flows: ProcessScanner → Worker → SignalR Hub → Desktop ViewModels. Key modules: Core/Interop (ProcessCommandLineReader), Service/Core (ProcessScanner, PerformanceMonitor), Desktop/ViewModels (FloatingWindowViewModel with ProcessRowViewModel).",
  "relevant_files": [
    {
      "path": "XhMonitor.Service/Core/ProcessScanner.cs",
      "relevance": 0.95,
      "rationale": "Primary integration point - creates ProcessInfo objects with ProcessName from Process.ProcessName (line 70, 104). Ideal location for name resolution at data source."
    },
    {
      "path": "XhMonitor.Core/Models/ProcessInfo.cs",
      "relevance": 0.90,
      "rationale": "Core data model - defines ProcessName property (line 6). Adding DisplayName field here enables separation of original vs friendly names."
    },
    {
      "path": "XhMonitor.Core/Interop/ProcessCommandLineReader.cs",
      "relevance": 0.85,
      "rationale": "Provides CommandLine extraction (line 15-26). CommandLine contains arguments needed for name parsing (e.g., --model for llamacpp)."
    },
    {
      "path": "XhMonitor.Service/Worker.cs",
      "relevance": 0.75,
      "rationale": "Data pipeline orchestrator - maps ProcessInfo to SignalR DTO (line 254-260). Alternative integration point before transmission."
    },
    {
      "path": "XhMonitor.Desktop/ViewModels/FloatingWindowViewModel.cs",
      "relevance": 0.70,
      "rationale": "UI consumer - ProcessRowViewModel displays ProcessName (line 375-378, 406, 413). Frontend integration point but violates DRY if multiple clients exist."
    },
    {
      "path": "XhMonitor.Desktop/Models/ProcessInfoDto.cs",
      "relevance": 0.65,
      "rationale": "Data transfer object - defines ProcessName for SignalR transmission (line 10-11). DTO mapping point for name transformation."
    },
    {
      "path": "XhMonitor.Core/Interfaces/IMetricProvider.cs",
      "relevance": 0.60,
      "rationale": "Existing DisplayName pattern (line 19) - demonstrates established convention for friendly names in metric providers. Can be applied to process names."
    },
    {
      "path": "XhMonitor.Service/Controllers/MetricsController.cs",
      "relevance": 0.55,
      "rationale": "API endpoint - exposes ProcessName via REST API (line 40, 45, 58). Must apply same name resolution to maintain consistency across SignalR and HTTP channels."
    }
  ],
  "patterns": "1. Provider Pattern: IMetricProvider interface with DisplayName property (IMetricProvider.cs:19) - established pattern for friendly names. Apply similar pattern with IProcessNameResolver interface.\n\n2. Dependency Injection: ProcessScanner receives ILogger and IConfiguration via constructor (ProcessScanner.cs:13-21). Follow same pattern to inject IProcessNameResolver.\n\n3. Data Flow: ProcessScanner.ScanProcesses() → Worker.SendProcessDataAsync() → SignalR Hub broadcast → FloatingWindowViewModel.OnProcessDataReceived() → ProcessRowViewModel.UpdateFrom(). ProcessName flows unchanged through entire pipeline.\n\n4. Parallel Processing: ProcessScanner uses Parallel.ForEach with MaxDegreeOfParallelism=4 (line 34-54). Name resolution must be thread-safe.\n\n5. Model Immutability: ProcessInfo uses init-only properties (ProcessInfo.cs:5-8). Adding DisplayName requires mutable property or constructor-based initialization.\n\n6. DTO Mapping: Worker maps ProcessInfo to anonymous DTO (Worker.cs:254-260). Transformation point for DisplayName injection.\n\n7. MVVM Pattern: ProcessRowViewModel binds ProcessName to UI (FloatingWindowViewModel.cs:375-378). UI expects string property for data binding.",
  "dependencies": "1. System.Diagnostics.Process: Source of original ProcessName (ProcessScanner.cs:30, 70)\n2. ProcessCommandLineReader (XhMonitor.Core.Interop): Provides CommandLine for argument parsing (ProcessScanner.cs:75)\n3. ILogger<ProcessScanner>: Logging infrastructure for name resolution diagnostics\n4. IConfiguration: Configuration source for keyword matching (ProcessScanner.cs:17-18)\n5. SignalR Hub (Worker.cs:16, 250-261): Transmission channel requiring consistent DTO structure\n6. ObservableCollection: UI binding mechanism (FloatingWindowViewModel.cs:18-20)\n7. INotifyPropertyChanged: Property change notification for ProcessName updates (FloatingWindowViewModel.cs:370-429)",
  "integration_points": "**Option A (Recommended): Backend Source - ProcessScanner**\nLocation: XhMonitor.Service/Core/ProcessScanner.cs:104-107\nImplementation:\n1. Create IProcessNameResolver interface in XhMonitor.Core/Interfaces/\n2. Inject IProcessNameResolver into ProcessScanner constructor (line 13)\n3. Call resolver in ProcessSingleProcess() after line 104: `string displayName = _nameResolver.Resolve(processName, commandLine);`\n4. Modify ProcessInfo.cs to add DisplayName property (mutable or init-only)\n5. Set DisplayName in ProcessInfo creation (line 101-107)\nFile:Line: ProcessScanner.cs:104, ProcessInfo.cs:6\nAdvantages: Single source of truth, centralized logic, best performance, all consumers benefit\nConstraints: Must preserve original ProcessName for internal use, resolver must be thread-safe\n\n**Option B: Backend Transmission - Worker/Hub**\nLocation: XhMonitor.Service/Worker.cs:254-260\nImplementation:\n1. Create IProcessNameResolver service\n2. Inject into Worker constructor (line 22-35)\n3. Transform ProcessName during DTO mapping: `ProcessName = _nameResolver.Resolve(m.Info.ProcessName, m.Info.CommandLine)`\nFile:Line: Worker.cs:257\nAdvantages: Separation of concerns, preserves raw data internally\nConstraints: Must apply to MetricsController.cs API endpoints for consistency, potential duplicate resolution if multiple hubs\n\n**Option C (Not Recommended): Frontend - ProcessRowViewModel**\nLocation: XhMonitor.Desktop/ViewModels/FloatingWindowViewModel.cs:411-419\nImplementation:\n1. Add ResolveFriendlyName() method to ProcessRowViewModel\n2. Call in UpdateFrom() method: `ProcessName = ResolveFriendlyName(dto.ProcessName, dto.CommandLine);`\nFile:Line: FloatingWindowViewModel.cs:413\nAdvantages: UI-only change, no backend impact\nConstraints: Violates DRY (duplicate logic if Web UI added), UI thread overhead, increased network payload (full CommandLine transmitted)",
  "constraints": "1. Thread Safety: ProcessScanner uses Parallel.ForEach (ProcessScanner.cs:39) - name resolver must be stateless or use thread-safe collections.\n\n2. Performance: ProcessScanner logs timing (line 56-57) - name resolution must be fast (<1ms per process) to avoid impacting scan performance. Consider caching for repeated patterns.\n\n3. Backward Compatibility: ProcessInfo is used by multiple consumers (Worker, MetricsController, Repository) - adding DisplayName must not break existing code. Use optional property or default to ProcessName.\n\n4. Data Consistency: ProcessName exposed via both SignalR (Worker.cs:250-261) and REST API (MetricsController.cs:40, 58) - name resolution must be applied consistently across all channels.\n\n5. Configuration: ProcessScanner uses IConfiguration for keywords (line 17-18) - name resolution rules should be configurable (e.g., enable/disable per process type, custom regex patterns).\n\n6. Extensibility: Multiple process types require different parsing rules (llamacpp --model, python script.py, etc.) - use Strategy pattern with IProcessNameStrategy implementations.\n\n7. Logging: ProcessScanner logs warnings for failed processes (line 47-48, 87-89) - name resolution failures should be logged but not block process scanning.\n\n8. Model Immutability: ProcessInfo uses init-only properties (ProcessInfo.cs:5-8) - DisplayName must be set during construction or use mutable property.\n\n9. UI Binding: ProcessRowViewModel uses INotifyPropertyChanged (FloatingWindowViewModel.cs:421-428) - ProcessName changes must trigger property notifications.\n\n10. Network Payload: CommandLine can be long (ProcessInfoDto.cs:14) - consider truncating or not transmitting if only DisplayName is needed by UI.",
  "clarification_needs": [
    {
      "question": "Where should the process name resolution logic be integrated?",
      "context": "Three integration points identified: (A) Backend source in ProcessScanner where ProcessInfo is created, (B) Backend transmission in Worker/Hub during DTO mapping, (C) Frontend in ProcessRowViewModel after receiving data. Each has different trade-offs for maintainability, performance, and architecture.",
      "options": [
        "Option A: Backend Source (ProcessScanner) - Add IProcessNameResolver service, inject into ProcessScanner, resolve at data creation time. Pros: Single source of truth, best performance, centralized logic. Cons: Couples scanning with display logic.",
        "Option B: Backend Transmission (Worker/Hub) - Resolve during DTO mapping before SignalR transmission. Pros: Separation of concerns, preserves raw data internally. Cons: Must apply to all API endpoints, potential duplicate resolution.",
        "Option C: Frontend (ProcessRowViewModel) - Resolve in UI ViewModel after receiving data. Pros: UI-only change, no backend impact. Cons: Violates DRY, UI thread overhead, increased network payload."
      ],
      "recommended": 0
    },
    {
      "question": "Should the original ProcessName be preserved alongside the DisplayName?",
      "context": "ProcessInfo currently has only ProcessName property. Adding DisplayName allows showing friendly names while preserving original for internal use (logging, filtering, database queries). However, this increases model complexity and memory usage.",
      "options": [
        "Add DisplayName property to ProcessInfo, keep original ProcessName - Allows internal code to use raw name, UI uses DisplayName. Requires model change and DTO update.",
        "Replace ProcessName with DisplayName, discard original - Simpler model, but loses original name for debugging/filtering. May break existing code expecting raw process names.",
        "Add DisplayName only to DTO layer (ProcessInfoDto), keep ProcessInfo unchanged - Minimal model impact, but resolution happens at transmission layer (Option B integration point)."
      ],
      "recommended": 0
    },
    {
      "question": "How should process-specific name extraction rules be implemented?",
      "context": "Different processes require different parsing rules (llamacpp uses --model flag, Python scripts have .py filename, Node.js has script path). Need extensible architecture to support multiple process types without hardcoding if-else chains.",
      "options": [
        "Strategy Pattern with IProcessNameStrategy - Create interface with TryResolve(processName, commandLine, out displayName) method. Implement strategies for each process type (LlamaCppStrategy, PythonScriptStrategy). Chain of Responsibility to try strategies in order.",
        "Regex Configuration - Store regex patterns in appsettings.json with capture groups for name extraction. Example: { \"llamacpp\": \"--model\\\\s+([^\\\\s]+)\" }. Simple but less flexible for complex parsing.",
        "Plugin System - Load strategies from external assemblies via IProcessNameResolver interface. Allows users to add custom rules without recompiling. Most flexible but adds complexity."
      ],
      "recommended": 0
    },
    {
      "question": "Should name resolution be configurable (enable/disable per process type)?",
      "context": "Users may want to disable friendly names for certain processes or globally. Configuration allows customization without code changes. However, adds configuration complexity and testing surface.",
      "options": [
        "Add configuration section in appsettings.json - Enable/disable globally and per-process-type. Example: { \"ProcessNameResolution\": { \"Enabled\": true, \"EnabledProcesses\": [\"llamacpp\", \"python\"] } }",
        "No configuration, always enabled - Simpler implementation, but users cannot opt-out if they prefer original names or encounter parsing issues.",
        "UI toggle in Settings window - Allow users to enable/disable via SettingsViewModel. Requires settings persistence and SignalR notification to backend."
      ],
      "recommended": 0
    }
  ],
  "_metadata": {
    "timestamp": "2026-01-13T00:00:00Z",
    "task_description": "当前进程监控名称显示对用户来说不够友好，比如llamacpp 运行了很多模型，我想让其能显示模型名称，名称在进程运行命令上，但是难点是，各种进程不同规则我如何能正确的提取名称呢，请你给出一些方案让我选择，请你结合当前项目架构进行考虑，且注意编程实践规范",
    "source": "cli-explore-agent",
    "exploration_angle": "integration-points",
    "exploration_index": 2,
    "total_explorations": 3,
    "duration_seconds": 180
  }
}
