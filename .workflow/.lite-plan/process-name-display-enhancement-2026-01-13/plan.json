{
  "summary": "Implement a flexible process name extraction system to display user-friendly names for monitored processes. The solution uses a hybrid approach with built-in extraction strategies for common processes (llamacpp, Python, Node.js) and configurable regex patterns for custom cases. Integration at the ProcessScanner level ensures centralized logic and optimal performance.",
  "approach": "Follow the existing provider pattern (IMetricProvider) to create an IProcessNameResolver service with multiple extraction strategies. Integrate at ProcessScanner.ProcessSingleProcess() where CommandLine is first obtained. Add DisplayName property to ProcessInfo model while preserving original ProcessName for internal use. Extend ProcessInfoDto and UI ViewModels to display friendly names. Configure extraction rules in appsettings.json with built-in strategies as defaults.",
  "tasks": [
    {
      "id": "T1",
      "title": "Implement ProcessNameResolver service with extraction strategies",
      "scope": "XhMonitor.Core/Services/",
      "action": "Create",
      "description": "Create IProcessNameResolver interface and ProcessNameResolver service with strategy pattern for name extraction. Implement built-in strategies for common processes (LlamaCppStrategy, PythonScriptStrategy, NodeJsStrategy) and a configurable RegexStrategy for custom patterns.",
      "modification_points": [
        {
          "file": "XhMonitor.Core/Interfaces/IProcessNameResolver.cs",
          "target": "new file",
          "change": "Define interface with Resolve(processName, commandLine) method"
        },
        {
          "file": "XhMonitor.Core/Services/ProcessNameResolver.cs",
          "target": "new file",
          "change": "Implement resolver with strategy chain (built-in + regex fallback)"
        },
        {
          "file": "XhMonitor.Core/Services/Strategies/LlamaCppStrategy.cs",
          "target": "new file",
          "change": "Extract model name from --model or -m flag"
        },
        {
          "file": "XhMonitor.Core/Services/Strategies/PythonScriptStrategy.cs",
          "target": "new file",
          "change": "Extract script filename from python command"
        },
        {
          "file": "XhMonitor.Core/Services/Strategies/NodeJsStrategy.cs",
          "target": "new file",
          "change": "Extract script filename from node command"
        },
        {
          "file": "XhMonitor.Core/Services/Strategies/RegexStrategy.cs",
          "target": "new file",
          "change": "Apply configurable regex patterns from appsettings.json"
        }
      ],
      "implementation": [
        "Create IProcessNameResolver interface with Resolve(string processName, string commandLine) method returning string",
        "Implement ProcessNameResolver with constructor accepting IConfiguration and ILogger",
        "Load extraction rules from appsettings.json Monitor:ProcessNameRules section",
        "Implement strategy chain: try built-in strategies first (LlamaCpp, Python, NodeJs), then regex patterns, finally fallback to original processName",
        "Each strategy implements TryExtract(processName, commandLine, out displayName) returning bool",
        "Cache compiled regex patterns in RegexStrategy to avoid repeated compilation overhead",
        "Add thread-safe implementation (strategies should be stateless or use thread-local state)"
      ],
      "reference": {
        "pattern": "Provider Pattern",
        "files": [
          "XhMonitor.Core/Interfaces/IMetricProvider.cs",
          "XhMonitor.Service/Core/MetricProviderRegistry.cs",
          "XhMonitor.Core/Providers/CpuMetricProvider.cs"
        ],
        "examples": "Follow IMetricProvider pattern with DisplayName property. ProcessNameResolver should be similar to MetricProviderRegistry but simpler (no dynamic assembly loading)."
      },
      "acceptance": [
        "IProcessNameResolver interface defined with Resolve method",
        "ProcessNameResolver service implements strategy chain with 3+ built-in strategies",
        "Regex patterns are cached and thread-safe",
        "Fallback to original processName when no strategy matches"
      ]
    },
    {
      "id": "T2",
      "title": "Extend data models with DisplayName property",
      "scope": "XhMonitor.Core/Models/, XhMonitor.Desktop/Models/",
      "action": "Update",
      "description": "Add DisplayName property to ProcessInfo domain model and ProcessInfoDto transfer object. Maintain immutability pattern for ProcessInfo and ensure backward compatibility.",
      "modification_points": [
        {
          "file": "XhMonitor.Core/Models/ProcessInfo.cs",
          "target": "properties:5-8",
          "change": "Add public string? DisplayName { get; init; } property"
        },
        {
          "file": "XhMonitor.Desktop/Models/ProcessInfoDto.cs",
          "target": "properties:10-17",
          "change": "Add [JsonPropertyName(\"displayName\")] public string DisplayName { get; set; } = string.Empty;"
        }
      ],
      "implementation": [
        "Add DisplayName property to ProcessInfo with init-only setter to maintain immutability",
        "Add DisplayName property to ProcessInfoDto with JsonPropertyName attribute for serialization",
        "Ensure DisplayName is nullable in ProcessInfo (string?) to indicate optional value",
        "ProcessInfoDto DisplayName should default to empty string for backward compatibility"
      ],
      "reference": {
        "pattern": "DTO Pattern",
        "files": [
          "XhMonitor.Core/Models/ProcessInfo.cs",
          "XhMonitor.Desktop/Models/ProcessInfoDto.cs"
        ],
        "examples": "Follow existing property patterns with required init for ProcessInfo and JsonPropertyName for DTO."
      },
      "acceptance": [
        "ProcessInfo has DisplayName property with init-only setter",
        "ProcessInfoDto has DisplayName property with JsonPropertyName attribute",
        "Existing code compiles without changes (backward compatible)",
        "DisplayName is properly serialized in SignalR transmission"
      ]
    },
    {
      "id": "T3",
      "title": "Integrate ProcessNameResolver into ProcessScanner",
      "scope": "XhMonitor.Service/Core/",
      "action": "Update",
      "description": "Inject IProcessNameResolver into ProcessScanner and call resolver in ProcessSingleProcess() method after CommandLine extraction. Set DisplayName in ProcessInfo creation. Register service in dependency injection container.",
      "modification_points": [
        {
          "file": "XhMonitor.Service/Core/ProcessScanner.cs",
          "target": "constructor:13-21",
          "change": "Add IProcessNameResolver parameter to constructor"
        },
        {
          "file": "XhMonitor.Service/Core/ProcessScanner.cs",
          "target": "ProcessSingleProcess:75-107",
          "change": "Call _nameResolver.Resolve() after line 75 and set DisplayName in ProcessInfo creation"
        },
        {
          "file": "XhMonitor.Service/Program.cs",
          "target": "service registration",
          "change": "Register IProcessNameResolver with ProcessNameResolver implementation"
        }
      ],
      "implementation": [
        "Add IProcessNameResolver _nameResolver field to ProcessScanner",
        "Update constructor to accept IProcessNameResolver and assign to field",
        "After line 75 (commandLine extraction), call: string displayName = _nameResolver.Resolve(processName, commandLine ?? string.Empty);",
        "Update ProcessInfo creation (lines 101-107) to include DisplayName = displayName",
        "Register service in Program.cs: builder.Services.AddSingleton<IProcessNameResolver, ProcessNameResolver>();",
        "Ensure resolver is called within try-catch to prevent process scanning failures"
      ],
      "reference": {
        "pattern": "Dependency Injection",
        "files": [
          "XhMonitor.Service/Core/ProcessScanner.cs",
          "XhMonitor.Service/Program.cs"
        ],
        "examples": "Follow existing DI pattern with ILogger and IConfiguration injection in ProcessScanner constructor."
      },
      "acceptance": [
        "ProcessScanner constructor accepts IProcessNameResolver",
        "Resolver is called in ProcessSingleProcess() after CommandLine extraction",
        "DisplayName is set in ProcessInfo creation",
        "Service is registered in Program.cs DI container",
        "Process scanning continues even if name resolution fails"
      ],
      "depends_on": ["T1", "T2"]
    },
    {
      "id": "T4",
      "title": "Update UI ViewModels to display friendly names",
      "scope": "XhMonitor.Desktop/ViewModels/",
      "action": "Update",
      "description": "Modify FloatingWindowViewModel.ProcessRowViewModel to use DisplayName instead of ProcessName for UI display. Update UpdateFrom() method to handle DisplayName from DTO. Maintain INotifyPropertyChanged pattern for property updates.",
      "modification_points": [
        {
          "file": "XhMonitor.Desktop/ViewModels/FloatingWindowViewModel.cs",
          "target": "ProcessRowViewModel:370-429",
          "change": "Add DisplayName property and update UpdateFrom() to set DisplayName from DTO"
        },
        {
          "file": "XhMonitor.Desktop/ViewModels/FloatingWindowViewModel.cs",
          "target": "UpdateFrom:411-419",
          "change": "Add DisplayName = dto.DisplayName ?? dto.ProcessName; to handle fallback"
        }
      ],
      "implementation": [
        "Add DisplayName property to ProcessRowViewModel with INotifyPropertyChanged pattern",
        "Update UpdateFrom() method to set DisplayName from DTO with fallback to ProcessName",
        "Implement fallback logic: DisplayName = !string.IsNullOrEmpty(dto.DisplayName) ? dto.DisplayName : dto.ProcessName;",
        "Keep ProcessName property for internal use (filtering, logging)",
        "UI bindings will be updated in T5 to use DisplayName"
      ],
      "reference": {
        "pattern": "MVVM Pattern",
        "files": [
          "XhMonitor.Desktop/ViewModels/FloatingWindowViewModel.cs"
        ],
        "examples": "Follow existing ProcessName property pattern (lines 374-379) with SetField helper for change notification."
      },
      "acceptance": [
        "ProcessRowViewModel has DisplayName property with INotifyPropertyChanged",
        "UpdateFrom() sets DisplayName from DTO with fallback to ProcessName",
        "Property change notifications work correctly",
        "Original ProcessName property is preserved for internal use"
      ],
      "depends_on": ["T2"]
    },
    {
      "id": "T5",
      "title": "Configure extraction rules and update UI bindings",
      "scope": "XhMonitor.Service/, XhMonitor.Desktop/",
      "action": "Configure",
      "description": "Add ProcessNameRules configuration section to appsettings.json with built-in rules for common processes. Update XAML bindings in FloatingWindow to display DisplayName instead of ProcessName.",
      "modification_points": [
        {
          "file": "XhMonitor.Service/appsettings.json",
          "target": "Monitor section:13-16",
          "change": "Add ProcessNameRules array with regex patterns for llamacpp, python, node"
        },
        {
          "file": "XhMonitor.Desktop/Views/FloatingWindow.xaml",
          "target": "ProcessName bindings",
          "change": "Update TextBlock bindings from ProcessName to DisplayName"
        }
      ],
      "implementation": [
        "Add Monitor:ProcessNameRules section to appsettings.json with structure: [{ \"ProcessName\": \"llama-server\", \"Pattern\": \"-m\\\\s+([^\\\\s]+)\", \"Group\": 1 }]",
        "Include rules for: llama-server/llamacpp (--model/-m flag), python (script.py filename), node (script.js filename)",
        "Update FloatingWindow.xaml TextBlock bindings to use DisplayName property",
        "Test configuration loading in ProcessNameResolver constructor",
        "Verify UI displays friendly names for configured processes"
      ],
      "reference": {
        "pattern": "Configuration Pattern",
        "files": [
          "XhMonitor.Service/appsettings.json"
        ],
        "examples": "Follow existing Monitor:Keywords pattern (lines 13-16) with nested array structure."
      },
      "acceptance": [
        "appsettings.json has ProcessNameRules section with 3+ rules",
        "Configuration is loaded correctly by ProcessNameResolver",
        "UI displays DisplayName for processes with matching rules",
        "UI falls back to ProcessName for processes without rules"
      ],
      "depends_on": ["T4"]
    }
  ],
  "focus_paths": [
    "XhMonitor.Core/Interfaces/IProcessNameResolver.cs",
    "XhMonitor.Core/Services/ProcessNameResolver.cs",
    "XhMonitor.Core/Services/Strategies/",
    "XhMonitor.Core/Models/ProcessInfo.cs",
    "XhMonitor.Desktop/Models/ProcessInfoDto.cs",
    "XhMonitor.Service/Core/ProcessScanner.cs",
    "XhMonitor.Service/Program.cs",
    "XhMonitor.Desktop/ViewModels/FloatingWindowViewModel.cs",
    "XhMonitor.Service/appsettings.json",
    "XhMonitor.Desktop/Views/FloatingWindow.xaml"
  ],
  "estimated_time": "2-3 hours",
  "recommended_execution": "Agent",
  "complexity": "Medium",
  "_metadata": {
    "timestamp": "2026-01-13T00:00:00Z",
    "source": "direct-planning",
    "planning_mode": "direct",
    "exploration_angles": ["patterns", "integration-points", "testing"],
    "duration_seconds": 300
  }
}