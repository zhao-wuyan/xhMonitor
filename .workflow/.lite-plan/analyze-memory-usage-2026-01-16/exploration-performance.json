{
  "project_structure": "C# .NET 8 solution with 4 main projects: XhMonitor.Service (ASP.NET Core backend with SignalR), XhMonitor.Desktop (WPF client), XhMonitor.Core (shared models/providers), XhMonitor.Tests. Service uses background workers (Worker.cs, AggregationWorker.cs, DatabaseCleanupWorker.cs) for continuous monitoring. Core architecture: ProcessScanner → PerformanceMonitor → MetricProviders → MetricRepository → SignalR Hub → Desktop Client.",

  "relevant_files": [
    {
      "path": "XhMonitor.Service/Core/ProcessScanner.cs",
      "relevance": 0.95,
      "rationale": "Scans ALL system processes (Process.GetProcesses()) every cycle, creates ProcessInfo objects with command lines. Uses Parallel.ForEach with MaxDegreeOfParallelism=4. Each process creates new ProcessInfo with strings (ProcessName, CommandLine, DisplayName, MatchedKeywords list). Line 36: Process.GetProcesses() returns all processes. Line 114-121: Creates new ProcessInfo per matched process."
    },
    {
      "path": "XhMonitor.Service/Core/PerformanceMonitor.cs",
      "relevance": 0.92,
      "rationale": "Collects metrics for all scanned processes using ConcurrentBag<ProcessMetrics>. Line 39: Creates new ConcurrentBag per cycle. Line 62-77: Creates Dictionary<string, MetricValue> per process. Line 79-84: Creates ProcessMetrics with nested dictionaries. No cleanup of old data between cycles."
    },
    {
      "path": "XhMonitor.Service/Worker.cs",
      "relevance": 0.90,
      "rationale": "Main background service orchestrating collection cycles. Line 237: Calls CollectAllAsync() every _intervalSeconds (default 5s). Line 252-259: Serializes ALL metrics to anonymous objects for SignalR broadcast. Creates new object graph per cycle. No memory pressure handling or GC hints."
    },
    {
      "path": "XhMonitor.Desktop/ViewModels/FloatingWindowViewModel.cs",
      "relevance": 0.88,
      "rationale": "Desktop client maintains 3 ObservableCollections (TopProcesses, AllProcesses, PinnedProcesses) and Dictionary<int, ProcessRowViewModel> _processIndex. Line 284-308: SyncProcessIndex creates new ProcessRowViewModel per process, never clears old entries until process exits. Line 319-348: SyncCollectionOrder performs collection manipulation every update cycle."
    },
    {
      "path": "XhMonitor.Service/Data/Repositories/MetricRepository.cs",
      "relevance": 0.85,
      "rationale": "Persists metrics to SQLite database. Line 49: Creates List<ProcessMetricRecord> from all metrics. Line 67: Serializes entire Metrics dictionary to JSON string per record. Line 53: AddRangeAsync adds all records to EF Core context. Database grows continuously without cleanup (handled by separate DatabaseCleanupWorker)."
    },
    {
      "path": "XhMonitor.Core/Providers/SystemMetricProvider.cs",
      "relevance": 0.75,
      "rationale": "Caches PerformanceCounter objects in List<PerformanceCounter> _vramCounters. Line 134-142: Enumerates GPU instances and creates counters. Counters are never disposed. Line 166-173: Iterates all counters every second for VRAM usage."
    },
    {
      "path": "XhMonitor.Core/Providers/MemoryMetricProvider.cs",
      "relevance": 0.70,
      "rationale": "Creates Process object per metric collection. Line 59: Process.GetProcessById() creates new Process handle. Uses 'using' for disposal but called frequently (every 5s for all processes). WorkingSet64 access may trigger OS memory queries."
    },
    {
      "path": "XhMonitor.Core/Services/ProcessNameResolver.cs",
      "relevance": 0.65,
      "rationale": "Maintains ConcurrentDictionary<string, Regex> _regexCache for compiled regexes. Line 24: Cache grows unbounded as new command line patterns are encountered. Dictionary<string, List<ProcessNameRule>> _rulesByProcess groups rules by process name."
    },
    {
      "path": "XhMonitor.Desktop/Services/SignalRService.cs",
      "relevance": 0.60,
      "rationale": "Receives SignalR messages and deserializes JSON to DTOs. Line 76: Deserializes ProcessDataDto with all process metrics every cycle. Line 50, 63: Deserializes HardwareLimitsDto and SystemUsageDto. Creates new DTO objects every message, relies on GC for cleanup."
    },
    {
      "path": "XhMonitor.Core/Models/ProcessMetrics.cs",
      "relevance": 0.55,
      "rationale": "Data model with Dictionary<string, MetricValue> Metrics property. Line 6: Dictionary created per ProcessMetrics instance. Contains ProcessInfo (with strings) and timestamp. No pooling or reuse."
    }
  ],

  "patterns": "**Memory Allocation Patterns:**\n1. **Per-Cycle Allocations**: Every collection cycle (5s) creates: ConcurrentBag<ProcessInfo> (ProcessScanner.cs:32), ConcurrentBag<ProcessMetrics> (PerformanceMonitor.cs:39), List<ProcessMetricRecord> (MetricRepository.cs:49), anonymous objects for SignalR (Worker.cs:252-259)\n2. **String Duplication**: ProcessInfo stores ProcessName, CommandLine, DisplayName as separate strings. CommandLine can be very long (full paths, arguments). No string interning or deduplication\n3. **Dictionary Per Process**: Each ProcessMetrics contains Dictionary<string, MetricValue> (ProcessMetrics.cs:6). For 100 processes, creates 100 dictionaries every 5s\n4. **No Object Pooling**: All objects are allocated fresh each cycle, no ArrayPool, ObjectPool, or struct usage\n5. **Collection Growth**: Desktop _processIndex (FloatingWindowViewModel.cs:14) grows as new processes appear, only removes on process exit\n6. **Regex Cache**: ProcessNameResolver._regexCache (ProcessNameResolver.cs:24) grows unbounded with unique command line patterns\n7. **PerformanceCounter Retention**: SystemMetricProvider._vramCounters (SystemMetricProvider.cs:20) holds PerformanceCounter objects indefinitely without disposal\n\n**Code Examples:**\n```csharp\n// ProcessScanner.cs:29-70 - Allocates ConcurrentBag + ProcessInfo per cycle\npublic List<ProcessInfo> ScanProcesses() {\n    var results = new ConcurrentBag<ProcessInfo>();\n    var processes = Process.GetProcesses(); // All system processes\n    Parallel.ForEach(processes, options, process => {\n        ProcessSingleProcess(process, results); // Creates ProcessInfo\n    });\n    return results.ToList(); // Another allocation\n}\n\n// PerformanceMonitor.cs:79-84 - Dictionary per process\nresults.Add(new ProcessMetrics {\n    Info = processInfo,\n    Metrics = metrics, // Dictionary<string, MetricValue>\n    Timestamp = cycleTimestamp\n});\n\n// Worker.cs:252-259 - Anonymous object graph for SignalR\nProcesses = metrics.Select(m => new {\n    m.Info.ProcessId,\n    m.Info.ProcessName,\n    m.Info.CommandLine, // Long strings\n    m.Info.DisplayName,\n    Metrics = m.Metrics // Entire dictionary\n}).ToList()\n```",

  "dependencies": "**Performance-Critical Dependencies:**\n1. **System.Diagnostics.Process**: Used for Process.GetProcesses() (ProcessScanner.cs:36) and Process.GetProcessById() (MemoryMetricProvider.cs:59, PerformanceMonitor.cs:54). Each call allocates native handles and managed wrappers\n2. **System.Diagnostics.PerformanceCounter**: Used for CPU/GPU/VRAM metrics. Cached in SystemMetricProvider._vramCounters (SystemMetricProvider.cs:20). Counters hold unmanaged resources\n3. **System.Collections.Concurrent.ConcurrentBag**: Used for parallel process collection (ProcessScanner.cs:32, PerformanceMonitor.cs:39). Thread-safe but higher memory overhead than List\n4. **Microsoft.EntityFrameworkCore**: Used for database persistence (MetricRepository.cs:45). DbContext tracks all entities in memory until SaveChanges. Using DbContextFactory pattern (line 22) helps but still creates context per save\n5. **Microsoft.AspNetCore.SignalR**: Used for real-time communication (Worker.cs:248). Serializes entire object graphs to JSON, holds in memory until sent\n6. **System.Text.Json**: Used for serialization (MetricRepository.cs:67, SignalRService.cs:76). Creates intermediate strings and objects during serialization\n7. **System.Management**: Used in MemoryMetricProvider.cs:26 for WMI queries (ManagementObjectSearcher). WMI objects are heavyweight\n\n**Dependency Impact:**\n- Process API: Each Process.GetProcesses() call allocates array of Process objects + native handles for ALL system processes (typically 100-300)\n- PerformanceCounter: Each counter holds native handle + internal buffers. SystemMetricProvider caches these indefinitely\n- EF Core: DbContext change tracker holds references to all entities until disposed. Using factory pattern mitigates but still creates context per cycle\n- SignalR: Serializes entire metric collection to JSON, creating intermediate strings and byte arrays",

  "integration_points": "**Memory Hotspots (file:line):**\n1. **ProcessScanner.cs:36** - `Process.GetProcesses()` - Returns ALL system processes, allocates Process[] + handles. Called every 5s\n2. **ProcessScanner.cs:114-121** - `new ProcessInfo { ... }` - Creates ProcessInfo with 4 string properties per matched process\n3. **PerformanceMonitor.cs:39** - `new ConcurrentBag<ProcessMetrics>()` - Allocates bag per cycle\n4. **PerformanceMonitor.cs:62** - `new Dictionary<string, MetricValue>()` - Dictionary per process per cycle\n5. **PerformanceMonitor.cs:79-84** - `new ProcessMetrics { ... }` - Wraps ProcessInfo + Dictionary\n6. **Worker.cs:237** - `await _monitor.CollectAllAsync()` - Triggers entire collection pipeline\n7. **Worker.cs:252-259** - Anonymous object creation for SignalR - Duplicates all data for serialization\n8. **MetricRepository.cs:49** - `metrics.Select(m => MapToEntity(m, cycleTimestamp)).ToList()` - Creates List<ProcessMetricRecord>\n9. **MetricRepository.cs:67** - `JsonSerializer.Serialize(source.Metrics, JsonOptions)` - Serializes dictionary to JSON string per record\n10. **FloatingWindowViewModel.cs:284-308** - `SyncProcessIndex()` - Maintains _processIndex dictionary, creates ProcessRowViewModel per new process\n11. **FloatingWindowViewModel.cs:319-348** - `SyncCollectionOrder()` - Manipulates ObservableCollections, triggers UI updates\n12. **SystemMetricProvider.cs:134-142** - PerformanceCounter creation loop - Allocates counters that are never disposed\n13. **ProcessNameResolver.cs:24** - `ConcurrentDictionary<string, Regex> _regexCache` - Grows unbounded with unique patterns\n\n**Data Flow (Memory Perspective):**\n```\nWorker.ExecuteAsync (5s interval)\n  ↓\nPerformanceMonitor.CollectAllAsync\n  ↓\nProcessScanner.ScanProcesses → Process.GetProcesses() [ALLOCATION: Process[] for all system processes]\n  ↓ Parallel.ForEach\nProcessSingleProcess → new ProcessInfo [ALLOCATION: ProcessInfo + 4 strings per matched process]\n  ↓\nCollectMetricSafeAsync → new Dictionary<string, MetricValue> [ALLOCATION: Dictionary per process]\n  ↓\nnew ProcessMetrics [ALLOCATION: Wrapper object per process]\n  ↓\nMetricRepository.SaveMetricsAsync → .ToList() + JsonSerializer.Serialize [ALLOCATION: List + JSON strings]\n  ↓\nSignalR broadcast → anonymous object graph [ALLOCATION: Duplicate object tree for serialization]\n  ↓\nDesktop SignalRService → JsonSerializer.Deserialize [ALLOCATION: DTO objects]\n  ↓\nFloatingWindowViewModel.SyncProcessIndex → new ProcessRowViewModel [ALLOCATION: ViewModel per new process]\n```",

  "constraints": "**Performance Constraints:**\n1. **High-Frequency Collection**: Service collects metrics every 5s (Worker.cs:35, 92), system usage every 1s (Worker.cs:204). Creates allocation pressure\n2. **Process.GetProcesses() Cost**: Returns ALL system processes (typically 100-300), not just monitored ones. Each call allocates Process[] + native handles (ProcessScanner.cs:36)\n3. **No Object Pooling**: No use of ArrayPool<T>, ObjectPool<T>, or struct-based value types. All allocations are heap-based\n4. **String Duplication**: ProcessInfo stores ProcessName, CommandLine, DisplayName separately. CommandLine can be 500+ chars. No string interning (ProcessScanner.cs:114-121)\n5. **Dictionary Overhead**: Each ProcessMetrics contains Dictionary<string, MetricValue>. For 100 processes, creates 100 dictionaries every 5s (PerformanceMonitor.cs:62)\n6. **SignalR Serialization**: Entire metric collection serialized to JSON every cycle. Creates intermediate strings and byte arrays (Worker.cs:252-259)\n7. **EF Core Change Tracking**: DbContext tracks all entities until SaveChanges. Using factory pattern helps but still creates context per cycle (MetricRepository.cs:45)\n8. **Desktop Collection Growth**: _processIndex dictionary grows as new processes appear, only removes on exit. Long-running desktop app accumulates process history (FloatingWindowViewModel.cs:14)\n9. **Unbounded Caches**: ProcessNameResolver._regexCache grows with unique command line patterns. SystemMetricProvider._vramCounters never disposed (ProcessNameResolver.cs:24, SystemMetricProvider.cs:20)\n10. **Parallel Overhead**: Uses Parallel.ForEach with MaxDegreeOfParallelism=4 for process scanning. Thread-safe collections (ConcurrentBag) have higher memory overhead (ProcessScanner.cs:40-60)\n11. **No GC Hints**: No explicit GC.Collect() calls or memory pressure notifications. Relies on automatic GC which may not trigger frequently enough under allocation pressure\n12. **Large Object Heap (LOH)**: Process.GetProcesses() array and JSON serialization strings may exceed 85KB threshold, allocated on LOH which is only compacted on full GC\n\n**Platform Constraints:**\n- .NET 8 GC: Uses workstation GC by default. Server GC would be more aggressive but requires configuration\n- Windows Process API: Process.GetProcesses() is expensive, queries kernel for all processes\n- WPF ObservableCollection: UI updates trigger property change notifications, creating event handler allocations (FloatingWindowViewModel.cs:18-20)\n- SignalR: Holds messages in memory until sent, backpressure can cause buildup",

  "clarification_needs": [
    {
      "question": "Should we optimize for lower memory usage at the cost of slightly higher CPU usage (e.g., object pooling, struct usage)?",
      "context": "Current implementation prioritizes code simplicity over memory efficiency. Introducing object pooling (ArrayPool, ObjectPool) and value types (structs) would reduce allocations but increase code complexity and CPU overhead for pool management.",
      "options": [
        "Yes - Prioritize memory reduction (use pooling, structs, reduce allocations)",
        "No - Keep current approach (simple code, rely on GC)",
        "Hybrid - Apply pooling only to hottest paths (ProcessScanner, PerformanceMonitor)"
      ],
      "recommended": 2
    },
    {
      "question": "Should we reduce the frequency of Process.GetProcesses() calls by caching process list and only refreshing on change detection?",
      "context": "ProcessScanner.ScanProcesses() calls Process.GetProcesses() every 5s, returning ALL system processes (100-300). This is the single largest allocation source. We could cache the process list and only refresh when process count changes, reducing allocations by 80%+.",
      "options": [
        "Yes - Cache process list, refresh only on count change",
        "No - Keep current approach (full scan every cycle for accuracy)",
        "Partial - Cache for N cycles (e.g., 3 cycles = 15s), then full refresh"
      ],
      "recommended": 0
    },
    {
      "question": "Should we limit the number of processes monitored simultaneously to cap memory usage?",
      "context": "Currently monitors ALL processes matching keywords. If keywords are broad (e.g., 'node', 'python'), could match 50+ processes. Desktop _processIndex grows unbounded. We could limit to top N processes by resource usage.",
      "options": [
        "Yes - Limit to top N processes (e.g., top 50 by memory/CPU)",
        "No - Monitor all matching processes (current behavior)",
        "Configurable - Add setting for max monitored processes"
      ],
      "recommended": 2
    },
    {
      "question": "Should we implement string interning for ProcessName and CommandLine to reduce duplicate string allocations?",
      "context": "Many processes have identical ProcessName (e.g., 'chrome.exe' x20). CommandLine often shares common prefixes. String interning could reduce memory by 30-50% for string data but adds CPU overhead for intern table lookups.",
      "options": [
        "Yes - Intern ProcessName and CommandLine prefixes",
        "No - Keep separate strings (current behavior)",
        "Selective - Intern only ProcessName (high duplication, short strings)"
      ],
      "recommended": 2
    }
  ],

  "_metadata": {
    "timestamp": "2026-01-16T00:00:00Z",
    "task_description": "分析service和desktop的内存占用过高的问题，service能占用800+mb的内存，desktop能占用110+mb的内存，service好像是在读取到进程数据之后暴涨。刚启动没读取进程之前是80MB左右的内存占用",
    "source": "cli-explore-agent",
    "exploration_angle": "performance",
    "exploration_index": 1,
    "total_explorations": 3,
    "duration_seconds": 180
  }
}
