{"id":"ISS-1769239097521-2","title":"Adopt IOptions pattern for configuration management","status":"registered","priority":3,"context":"Injecting IConfiguration directly creates high coupling to configuration keys and structure. It makes unit testing difficult and bypasses the validation/binding capabilities of the Options pattern. This violates .NET configuration best practices.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-003-c3f0e4a6","perspective":"best-practices","file":"XhMonitor.Service/Worker.cs","line":46,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-3","title":"Refactor App.xaml.cs to use Generic Host pattern","status":"registered","priority":3,"context":"App.xaml.cs is acting as a composition root and process orchestrator, mixing UI logic (creating windows) with backend service management. This violates separation of concerns and makes the application hard to test and maintain. Modern WPF applications should use Generic Host pattern.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-004-d4a1f5b7","perspective":"best-practices","file":"XhMonitor.Desktop/App.xaml.cs","line":25,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-4","title":"Adopt C# 12 primary constructors for cleaner code","status":"registered","priority":4,"context":"Verbose boilerplate for constructor dependency injection. .NET 8 / C# 12 supports Primary Constructors to reduce verbosity and improve code readability. The project targets .NET 8 but doesn't leverage modern C# 12 features.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-005-e5b2a6c8","perspective":"best-practices","file":"XhMonitor.Core/Providers/SystemMetricProvider.cs","line":27,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-5","title":"Fix unsafe async cleanup in application shutdown","status":"registered","priority":2,"context":"Calling async methods with _ = inside OnExit (a void method) creates a race condition. The application process may terminate before the cleanup tasks complete, potentially leaving orphaned backend processes or incomplete cleanup.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-006-f6c3b7d9","perspective":"best-practices","file":"XhMonitor.Desktop/App.xaml.cs","line":46,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-8","title":"Adopt C# 12 collection expressions for modern syntax","status":"registered","priority":5,"context":"Project uses old collection initialization syntax (new List<>, new Dictionary<>) instead of C# 12 collection expressions. Modern syntax improves readability and is more concise. Found in multiple files including LibreHardwareManager.cs:100, DxgiGpuMonitor.cs:199.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-009-c9f6e0a2","perspective":"best-practices","file":"XhMonitor.Core/Services/LibreHardwareManager.cs","line":100,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-9","title":"Replace synchronous semaphore wait with async WaitAsync","status":"registered","priority":3,"context":"Using _updateLock.Wait() (synchronous semaphore wait) in LibreHardwareManager.UpdateSnapshot() can cause thread pool starvation. Should use WaitAsync() for async-friendly synchronization.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-010-d0a7f1b3","perspective":"best-practices","file":"XhMonitor.Core/Services/LibreHardwareManager.cs","line":86,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-10","title":"Implement IAsyncDisposable for async resource cleanup","status":"registered","priority":3,"context":"Classes with async cleanup operations (LibreHardwareManager, SystemMetricProvider) only implement IDisposable, not IAsyncDisposable. This forces blocking async operations in Dispose(), which is an anti-pattern. SignalRService correctly implements IAsyncDisposable.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-011-e1b8c2d4","perspective":"best-practices","file":"XhMonitor.Core/Services/LibreHardwareManager.cs","line":11,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-11","title":"Add logging to exception handlers instead of empty catch","status":"registered","priority":3,"context":"Multiple empty catch blocks found that silently swallow exceptions without logging or handling. This makes debugging difficult and hides potential issues. Found in test files and tools, but pattern should be avoided.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-012-f2c9d3e5","perspective":"best-practices","file":"XhMonitor.Desktop/Services/SignalRService.cs","line":142,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-13","title":"Use configuration file for service executable location","status":"registered","priority":3,"context":"App.xaml.cs contains hardcoded relative paths ('..\\..\\..\\..\\XhMonitor.Service') to locate the backend service. This couples the runtime application to a specific development directory structure, which will fail in different deployment environments (production, CI/CD, user installations).","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-002-b2c3d4e5","perspective":"maintainability","file":"XhMonitor.Desktop/App.xaml.cs","line":314,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-14","title":"Extract DXGI and Performance Counter logic into separate provider classes","status":"registered","priority":3,"context":"SystemMetricProvider orchestrates high-level providers (Cpu/GpuProvider) but also contains low-level implementation details for DXGI monitoring and Performance Counters directly within the class. This mixing of abstraction levels violates the Single Level of Abstraction Principle and makes the class harder to understand and maintain.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-004-d4e5f6a7","perspective":"maintainability","file":"XhMonitor.Core/Providers/SystemMetricProvider.cs","line":13,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-15","title":"Centralize port configuration with dynamic fallback","status":"registered","priority":3,"context":"Ports 35179 (Service) and 35180 (Web) are hardcoded in multiple places across Desktop, Service, and configuration files. Port conflicts will cause the application to fail start without recourse. Changes require updating multiple files, increasing maintenance burden.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-006-f6a7b8c9","perspective":"maintainability","file":"XhMonitor.Desktop/App.xaml.cs","line":308,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-17","title":"Use collection-based provider management for dynamic metrics","status":"registered","priority":3,"context":"SystemMetricProvider defines specific fields for CPU, GPU, Memory, VRAM providers (_cpuProvider, _gpuProvider, etc.). This prevents dynamically adding new system-level metrics (e.g., Disk, Network) without changing the class structure. The design is not extensible for future metric types.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-008-b8c9d0e1","perspective":"maintainability","file":"XhMonitor.Core/Providers/SystemMetricProvider.cs","line":16,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-21","title":"Use factory pattern or DI for provider instantiation","status":"registered","priority":3,"context":"MetricProviderRegistry's RegisterBuiltInProviders method directly instantiates concrete provider classes (CpuMetricProvider, GpuMetricProvider, etc.) instead of using dependency injection or factory patterns. This creates tight coupling and makes it difficult to test or swap implementations.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-012-f2a3b4c5","perspective":"maintainability","file":"XhMonitor.Service/Core/MetricProviderRegistry.cs","line":185,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-23","title":"Extract process management into IProcessManager interface","status":"registered","priority":4,"context":"App.xaml.cs directly manages Process objects for Service and Web Server without any abstraction layer. This makes it difficult to test process lifecycle management and couples the application to specific process management implementation details.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-014-b4c5d6e7","perspective":"maintainability","file":"XhMonitor.Desktop/App.xaml.cs","line":342,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
{"id":"ISS-1769239097521-24","title":"Establish consistent error handling patterns for configuration","status":"registered","priority":4,"context":"Configuration loading in SettingsViewModel uses try-catch with generic error handling, while Program.cs throws exceptions for missing connection strings. This inconsistency makes it difficult to understand error handling patterns and leads to unpredictable behavior.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-015-c5d6e7f8","perspective":"maintainability","file":"XhMonitor.Desktop/ViewModels/SettingsViewModel.cs","line":85,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:18:17.521Z"}
