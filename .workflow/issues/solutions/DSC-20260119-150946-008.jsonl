{"id":"SOL-DSC-20260119-150946-008-k7m2","description":"Remove fake async wrappers from SystemMetricProvider by converting Task.Run-wrapped synchronous P/Invoke calls to direct synchronous methods. The GlobalMemoryStatusEx P/Invoke call is fast (<1ms) and wrapping it in Task.Run introduces unnecessary thread pool overhead without scalability benefits.","approach":"Convert GetMaxMemoryAsync() and GetMemoryUsageAsync() from async Task.Run wrappers to synchronous methods, then update callers to use synchronous access patterns. This eliminates thread pool overhead while maintaining correct behavior since the P/Invoke calls are CPU-bound and fast.","analysis":{"risk":"low","impact":"low","complexity":"low"},"score":0.95,"tasks":[{"id":"T1","title":"Convert GetMaxMemoryAsync to synchronous GetMaxMemory","scope":"XhMonitor.Core/Providers","action":"Refactor","description":"Remove Task.Run wrapper from GetMaxMemoryAsync and convert to synchronous GetMaxMemory method since GlobalMemoryStatusEx P/Invoke is fast and CPU-bound","modification_points":["XhMonitor.Core/Providers/SystemMetricProvider.cs:147-157"],"implementation":["Read SystemMetricProvider.cs to understand current implementation","Change method signature from 'private Task<double> GetMaxMemoryAsync()' to 'private double GetMaxMemory()'","Remove 'return Task.Run(() => { ... });' wrapper and return result directly","Keep the TryGetPhysicalMemoryDetails P/Invoke call as-is (it's already synchronous)","Verify method still returns 0.0 on failure"],"test":{"unit":["Verify GetMaxMemory returns correct total memory value","Verify GetMaxMemory returns 0.0 when P/Invoke fails","Verify method executes in <1ms (no thread pool overhead)"],"commands":["dotnet test --filter FullyQualifiedName~SystemMetricProviderTests"]},"acceptance":{"criteria":["GetMaxMemory method is synchronous (no Task return type)","No Task.Run wrapper present","P/Invoke call executes directly on calling thread","Method returns correct memory values","Performance: execution time <1ms"],"verification":["Code review: confirm no Task.Run wrapper","Unit test: verify return values match expected memory","Performance test: measure execution time <1ms"]},"commit":{"type":"refactor","scope":"SystemMetricProvider","message_template":"refactor(SystemMetricProvider): remove fake async from GetMaxMemory\n\nConvert GetMaxMemoryAsync to synchronous GetMaxMemory method.\nGlobalMemoryStatusEx P/Invoke is fast (<1ms) and CPU-bound,\nwrapping in Task.Run adds thread pool overhead without benefit."},"depends_on":[],"priority":1},{"id":"T2","title":"Convert GetMemoryUsageAsync to synchronous GetMemoryUsage","scope":"XhMonitor.Core/Providers","action":"Refactor","description":"Remove Task.Run wrapper from GetMemoryUsageAsync and convert to synchronous GetMemoryUsage method","modification_points":["XhMonitor.Core/Providers/SystemMetricProvider.cs:159-169"],"implementation":["Change method signature from 'private Task<double> GetMemoryUsageAsync()' to 'private double GetMemoryUsage()'","Remove 'return Task.Run(() => { ... });' wrapper and return result directly","Keep the TryGetPhysicalMemoryDetails P/Invoke call as-is","Verify calculation logic (totalMb - availMb) remains correct"],"test":{"unit":["Verify GetMemoryUsage returns correct used memory value","Verify GetMemoryUsage returns 0.0 when P/Invoke fails","Verify method executes in <1ms"],"commands":["dotnet test --filter FullyQualifiedName~SystemMetricProviderTests"]},"acceptance":{"criteria":["GetMemoryUsage method is synchronous (no Task return type)","No Task.Run wrapper present","P/Invoke call executes directly on calling thread","Method returns correct used memory values","Performance: execution time <1ms"],"verification":["Code review: confirm no Task.Run wrapper","Unit test: verify return values match expected used memory","Performance test: measure execution time <1ms"]},"commit":{"type":"refactor","scope":"SystemMetricProvider","message_template":"refactor(SystemMetricProvider): remove fake async from GetMemoryUsage\n\nConvert GetMemoryUsageAsync to synchronous GetMemoryUsage method.\nGlobalMemoryStatusEx P/Invoke is fast and CPU-bound."},"depends_on":["T1"],"priority":2},{"id":"T3","title":"Update GetHardwareLimitsAsync to use synchronous GetMaxMemory","scope":"XhMonitor.Core/Providers","action":"Update","description":"Update GetHardwareLimitsAsync to call synchronous GetMaxMemory instead of awaiting GetMaxMemoryAsync","modification_points":["XhMonitor.Core/Providers/SystemMetricProvider.cs:85-96"],"implementation":["Locate GetHardwareLimitsAsync method (lines 85-96)","Change 'var memoryTask = GetMaxMemoryAsync();' to direct call 'var maxMemory = GetMaxMemory();'","Remove memoryTask from Task.WhenAll (only await vramMaxTask)","Change 'MaxMemory = memoryTask.Result' to 'MaxMemory = maxMemory'","Simplify: 'await vramMaxTask;' then 'return new HardwareLimits { MaxMemory = maxMemory, MaxVram = vramMaxTask.Result };'"],"test":{"unit":["Verify GetHardwareLimitsAsync returns correct MaxMemory value","Verify async behavior still works correctly for VRAM","Integration test: verify Worker service receives correct hardware limits"],"commands":["dotnet test --filter FullyQualifiedName~SystemMetricProviderTests","dotnet test --filter FullyQualifiedName~WorkerTests"]},"acceptance":{"criteria":["GetHardwareLimitsAsync calls synchronous GetMaxMemory","No .Result access on completed synchronous operation","Method still returns correct HardwareLimits object","VRAM async operation still works correctly"],"verification":["Code review: confirm synchronous call pattern","Unit test: verify MaxMemory value correctness","Integration test: verify Worker receives correct data"]},"commit":{"type":"refactor","scope":"SystemMetricProvider","message_template":"refactor(SystemMetricProvider): use synchronous GetMaxMemory in GetHardwareLimitsAsync\n\nUpdate caller to use synchronous GetMaxMemory method."},"depends_on":["T1"],"priority":3},{"id":"T4","title":"Update GetSystemUsageAsync to use synchronous GetMemoryUsage","scope":"XhMonitor.Core/Providers","action":"Update","description":"Update GetSystemUsageAsync to call synchronous GetMemoryUsage instead of awaiting GetMemoryUsageAsync","modification_points":["XhMonitor.Core/Providers/SystemMetricProvider.cs:128-145"],"implementation":["Locate GetSystemUsageAsync method (lines 128-145)","Change 'var memoryTask = GetMemoryUsageAsync();' to direct call 'var totalMemory = GetMemoryUsage();'","Remove memoryTask from Task.WhenAll (keep cpuTask, gpuTask, vramTask)","Change 'TotalMemory = memoryTask.Result' to 'TotalMemory = totalMemory'","Simplify: 'await Task.WhenAll(cpuTask, gpuTask, vramTask);' then construct SystemUsage with totalMemory"],"test":{"unit":["Verify GetSystemUsageAsync returns correct TotalMemory value","Verify async behavior still works for CPU, GPU, VRAM","Integration test: verify Worker service receives correct system usage"],"commands":["dotnet test --filter FullyQualifiedName~SystemMetricProviderTests","dotnet test --filter FullyQualifiedName~WorkerTests"]},"acceptance":{"criteria":["GetSystemUsageAsync calls synchronous GetMemoryUsage","No .Result access on completed synchronous operation","Method still returns correct SystemUsage object","CPU/GPU/VRAM async operations still work correctly","No performance regression in Worker polling cycle"],"verification":["Code review: confirm synchronous call pattern","Unit test: verify TotalMemory value correctness","Integration test: verify Worker receives correct data","Performance test: verify Worker cycle time unchanged"]},"commit":{"type":"refactor","scope":"SystemMetricProvider","message_template":"refactor(SystemMetricProvider): use synchronous GetMemoryUsage in GetSystemUsageAsync\n\nUpdate caller to use synchronous GetMemoryUsage method.\nEliminates unnecessary Task.Run overhead for fast P/Invoke."},"depends_on":["T2"],"priority":4}],"is_bound":true,"bound_at":"2026-01-19T16:20:48.024Z"}
