{"id":"SOL-DSC-20260119-150946-010-p3n8","description":"Remove all blocking async operations (.Result, .Wait(), .GetAwaiter().GetResult()) that can cause deadlocks in UI contexts. Replace with proper async/await patterns or implement IAsyncDisposable for cleanup scenarios.","approach":"Address blocking async calls in three categories: (1) Window cleanup - implement async disposal pattern, (2) CancellationToken callbacks - use async registration, (3) Semaphore waits - convert to WaitAsync. Each fix maintains thread safety while eliminating deadlock risk.","analysis":{"risk":"medium","impact":"medium","complexity":"medium"},"score":0.9,"tasks":[{"id":"T1","title":"Implement async disposal pattern for FloatingWindow cleanup","scope":"XhMonitor.Desktop","action":"Refactor","description":"Replace blocking GetAwaiter().GetResult() in OnClosing with proper async disposal pattern using DisposeAsync","modification_points":["XhMonitor.Desktop/FloatingWindow.xaml.cs:714-721","XhMonitor.Desktop/ViewModels/FloatingWindowViewModel.cs:385-394"],"implementation":["Add IAsyncDisposable interface to FloatingWindowViewModel","Rename CleanupAsync to DisposeAsync (IAsyncDisposable contract)","In FloatingWindow.OnClosing, remove blocking call to CleanupAsync","Instead, fire-and-forget the cleanup: _ = _viewModel.DisposeAsync();","Add comment explaining fire-and-forget is safe during shutdown","Alternative: Use async void OnClosing if WPF supports it (check framework version)","Ensure SignalR disconnection happens asynchronously without blocking UI thread"],"test":{"unit":["Verify DisposeAsync unsubscribes all event handlers","Verify DisposeAsync calls DisconnectAsync on SignalR service","Verify window closes without blocking UI thread","Test rapid window close scenarios (no deadlock)"],"commands":["dotnet test --filter FullyQualifiedName~FloatingWindowTests","dotnet test --filter FullyQualifiedName~FloatingWindowViewModelTests"]},"acceptance":{"criteria":["FloatingWindowViewModel implements IAsyncDisposable","No blocking calls (.Result, .Wait(), .GetAwaiter().GetResult()) in OnClosing","Window closes immediately without UI freeze","SignalR cleanup happens asynchronously","No deadlocks during window close"],"verification":["Code review: confirm no blocking async calls","Manual test: close window rapidly, verify no freeze","Integration test: verify SignalR disconnects properly","Stress test: close/reopen window 100 times, no deadlock"]},"commit":{"type":"refactor","scope":"FloatingWindow","message_template":"refactor(FloatingWindow): implement async disposal pattern\n\nReplace blocking GetAwaiter().GetResult() with fire-and-forget\nDisposeAsync during window close. Prevents UI thread deadlock."},"depends_on":[],"priority":1},{"id":"T2","title":"Convert WebServerService CancellationToken callback to async","scope":"XhMonitor.Desktop/Services","action":"Refactor","description":"Replace blocking GetAwaiter().GetResult() in CancellationToken.Register callback with async-friendly pattern","modification_points":["XhMonitor.Desktop/Services/WebServerService.cs:55-58"],"implementation":["Locate CancellationToken.Register callback (line 55-58)","Option 1: Remove callback entirely, rely on app.RunAsync cancellation","Option 2: Use Register with async callback: _webServerCts.Token.Register(async () => await app.StopAsync())","Option 3: Store app reference and stop it in StopAsync method instead","Recommended: Option 1 - RunAsync already respects cancellation token","Verify app.RunAsync stops gracefully when _webServerCts is cancelled","Remove the Register callback block entirely"],"test":{"unit":["Verify web server stops when StopAsync is called","Verify no blocking calls during shutdown","Test cancellation token propagation"],"commands":["dotnet test --filter FullyQualifiedName~WebServerServiceTests"]},"acceptance":{"criteria":["No blocking async calls in CancellationToken callback","Web server stops gracefully on cancellation","No thread pool starvation during shutdown","Cancellation completes within 3 seconds"],"verification":["Code review: confirm no blocking calls","Integration test: verify web server stops on app exit","Performance test: measure shutdown time <3s"]},"commit":{"type":"refactor","scope":"WebServerService","message_template":"refactor(WebServerService): remove blocking async in cancellation callback\n\nRemove blocking GetAwaiter().GetResult() from CancellationToken.Register.\nRunAsync already handles cancellation gracefully."},"depends_on":[],"priority":2},{"id":"T3","title":"Convert LibreHardwareManager semaphore Wait to WaitAsync","scope":"XhMonitor.Core/Services","action":"Refactor","description":"Replace synchronous _updateLock.Wait() with async WaitAsync() to prevent thread pool starvation","modification_points":["XhMonitor.Core/Services/LibreHardwareManager.cs:86-93"],"implementation":["Locate UpdateSnapshot method containing _updateLock.Wait() (line 86)","Change method signature to 'public async Task UpdateSnapshot()' if not already async","Replace '_updateLock.Wait();' with 'await _updateLock.WaitAsync();'","Verify all callers of UpdateSnapshot are async and can await","If callers are synchronous, evaluate if they should be converted to async","Update all call sites to use 'await UpdateSnapshot();' instead of 'UpdateSnapshot();'","Ensure proper exception handling in try-finally block remains intact"],"test":{"unit":["Verify UpdateSnapshot acquires lock asynchronously","Verify lock is released in finally block","Test concurrent UpdateSnapshot calls (no thread pool starvation)","Verify snapshot update logic remains correct"],"commands":["dotnet test --filter FullyQualifiedName~LibreHardwareManagerTests"]},"acceptance":{"criteria":["UpdateSnapshot uses WaitAsync instead of Wait","Method signature is async Task","All callers properly await UpdateSnapshot","No thread pool starvation under concurrent load","Lock semantics preserved (mutual exclusion)"],"verification":["Code review: confirm WaitAsync usage","Unit test: verify lock behavior","Load test: 100 concurrent calls, no thread pool exhaustion","Integration test: verify hardware readings remain accurate"]},"commit":{"type":"refactor","scope":"LibreHardwareManager","message_template":"refactor(LibreHardwareManager): use async semaphore wait\n\nReplace synchronous Wait() with WaitAsync() to prevent\nthread pool starvation during concurrent snapshot updates."},"depends_on":[],"priority":3},{"id":"T4","title":"Remove .Result access in SystemMetricProvider after Task.WhenAll","scope":"XhMonitor.Core/Providers","action":"Refactor","description":"Replace .Result access pattern with proper await or direct variable usage after Task.WhenAll completes","modification_points":["XhMonitor.Core/Providers/SystemMetricProvider.cs:85-96","XhMonitor.Core/Providers/SystemMetricProvider.cs:128-145"],"implementation":["In GetHardwareLimitsAsync (lines 85-96):","After 'await Task.WhenAll(memoryTask, vramMaxTask);'","Replace 'MaxMemory = memoryTask.Result' with 'MaxMemory = await memoryTask'","Replace 'MaxVram = vramMaxTask.Result' with 'MaxVram = await vramMaxTask'","Alternative: Use 'var (maxMemory, maxVram) = await Task.WhenAll(...).ConfigureAwait(false);'","In GetSystemUsageAsync (lines 128-145):","After 'await Task.WhenAll(cpuTask, gpuTask, memoryTask, vramTask);'","Replace all .Result accesses with await or direct variable assignment","Note: After Task.WhenAll completes, tasks are already completed, so .Result is safe but not idiomatic","Prefer: Store results before Task.WhenAll or use tuple deconstruction"],"test":{"unit":["Verify GetHardwareLimitsAsync returns correct values","Verify GetSystemUsageAsync returns correct values","Test exception propagation (no AggregateException wrapping)","Verify async behavior unchanged"],"commands":["dotnet test --filter FullyQualifiedName~SystemMetricProviderTests"]},"acceptance":{"criteria":["No .Result access in GetHardwareLimitsAsync","No .Result access in GetSystemUsageAsync","Methods return correct hardware limits and system usage","Exception handling works correctly","Code follows async/await best practices"],"verification":["Code review: confirm no .Result usage","Unit test: verify return values","Exception test: verify proper exception propagation","Integration test: verify Worker receives correct data"]},"commit":{"type":"refactor","scope":"SystemMetricProvider","message_template":"refactor(SystemMetricProvider): remove .Result after Task.WhenAll\n\nReplace .Result access with proper await pattern.\nImproves code clarity and follows async/await best practices."},"depends_on":[],"priority":4},{"id":"T5","title":"Audit and document remaining .Result usage in test code","scope":"XhMonitor.Tests","action":"Document","description":"Review ProcessNameResolverTests.cs:281 .Result usage and document if acceptable in test context","modification_points":["XhMonitor.Tests/Services/ProcessNameResolverTests.cs:281"],"implementation":["Locate .Result usage in ProcessNameResolverTests.cs line 281","Analyze context: 'var results = tasks.Select(t => t.Result).Distinct().ToList();'","Determine if this is in a test method that can be made async","If test framework supports async tests, convert to: 'var results = await Task.WhenAll(tasks);'","If test framework doesn't support async, add comment explaining synchronous wait is acceptable in test context","Document: '// Test context: synchronous wait acceptable, no deadlock risk in xUnit/NUnit'","Verify test still passes after any changes"],"test":{"unit":["Verify ProcessNameResolverTests still pass","Verify test behavior unchanged"],"commands":["dotnet test --filter FullyQualifiedName~ProcessNameResolverTests"]},"acceptance":{"criteria":["Test code reviewed and documented","If possible, converted to async pattern","If not possible, comment added explaining rationale","All tests pass"],"verification":["Code review: confirm test pattern is appropriate","Test execution: verify all tests pass"]},"commit":{"type":"docs","scope":"tests","message_template":"docs(tests): document .Result usage in ProcessNameResolverTests\n\nAdd comment explaining synchronous wait is acceptable\nin test context where deadlock risk is minimal."},"depends_on":[],"priority":5}],"is_bound":true,"bound_at":"2026-01-19T16:20:50.759Z"}
