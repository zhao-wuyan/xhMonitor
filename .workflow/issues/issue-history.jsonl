{"id":"ISS-1768808736538-0","title":"Refactor App.xaml.cs into separate service orchestrator classes","status":"completed","priority":1,"context":"App.xaml.cs handles UI lifecycle, Tray Icon logic, Backend Service process management, Web Server process management, AND Node.js build steps (npm install/build). This massive violation of Single Responsibility Principle makes the class difficult to test, maintain, and understand. Changes to any one concern require modifying this central class.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-003-c3d4e5f6","perspective":"maintainability","file":"XhMonitor.Desktop/App.xaml.cs","line":14,"labels":["maintainability"],"created_at":"2026-01-19T07:45:36.539Z","updated_at":"2026-01-19T16:09:34.131Z","completed_at":"2026-01-19T16:09:34.061Z"}
{"id":"ISS-1768808736538-1","title":"Remove npm build logic from runtime application","status":"completed","priority":1,"context":"The application attempts to run 'npm install' and 'npm run build' on startup if the dist folder is missing. This introduces a runtime dependency on Node.js and npm, which is unacceptable for a production desktop application. Build steps should be part of CI/CD, not runtime logic.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-005-e5f6a7b8","perspective":"maintainability","file":"XhMonitor.Desktop/App.xaml.cs","line":518,"labels":["maintainability"],"created_at":"2026-01-19T07:45:36.539Z","updated_at":"2026-01-19T16:09:45.019Z","completed_at":"2026-01-19T16:09:44.948Z"}
{"id":"DSC-20260119-150946-003","discovery_id":"DSC-20260119-150946","title":"Concrete class dependency in Worker violates dependency inversion","type":"refactor","priority":"high","status":"completed","perspectives":["maintainability"],"category":"coupling","description":"Worker class directly injects concrete SystemMetricProvider instead of interface, preventing unit testing and violating dependency inversion principle.","file":"XhMonitor.Service/Worker.cs","line":33,"tags":["coupling","dependency-inversion","testability"],"confidence":0.95,"created_at":"2026-01-19T15:09:46+08:00","updated_at":"2026-01-24T07:02:59.032Z","bound_solution_id":"SOL-DSC-20260119-150946-003-k7m2","planned_at":"2026-01-19T16:19:31.855Z","completed_at":"2026-01-24T07:02:59.031Z"}
{"id":"DSC-20260119-150946-004","discovery_id":"DSC-20260119-150946","title":"Open/Closed Principle violation in SystemMetricProvider","type":"refactor","priority":"high","status":"completed","perspectives":["maintainability"],"category":"extensibility","description":"Uses type checking (is LibreHardwareMonitorVramProvider) to access specific methods not in interface. Adding new providers requires modifying this class.","file":"XhMonitor.Core/Providers/SystemMetricProvider.cs","line":179,"tags":["extensibility","open-closed","interface-design"],"confidence":0.92,"created_at":"2026-01-19T15:09:46+08:00","updated_at":"2026-01-24T07:03:10.064Z","bound_solution_id":"SOL-DSC-20260119-150946-004-p9x4","planned_at":"2026-01-19T16:19:34.818Z","completed_at":"2026-01-24T07:03:10.063Z"}
{"id":"DSC-20260119-150946-005","discovery_id":"DSC-20260119-150946","title":"Scattered configuration management across modules","type":"refactor","priority":"high","status":"completed","perspectives":["maintainability"],"category":"module-boundary","description":"Configuration scattered across appsettings.json, database, hardcoded defaults in ViewModels, and App.xaml.cs. Creates inconsistency and maintenance burden.","file":"XhMonitor.Desktop/ViewModels/SettingsViewModel.cs","line":13,"tags":["module-boundary","configuration","consistency"],"confidence":0.9,"created_at":"2026-01-19T15:09:46+08:00","updated_at":"2026-01-24T07:03:10.804Z","bound_solution_id":"SOL-DSC-20260119-150946-005-k7m2","planned_at":"2026-01-19T16:19:52.641Z","completed_at":"2026-01-24T07:03:10.803Z"}
{"id":"DSC-20260119-150946-006","discovery_id":"DSC-20260119-150946","title":"Desktop module directly depends on Service port configuration","type":"refactor","priority":"high","status":"completed","perspectives":["maintainability"],"category":"module-boundary","description":"Desktop hardcodes Service API endpoint (localhost:35179), creating tight coupling. Changes to Service port require updating Desktop code.","file":"XhMonitor.Desktop/ViewModels/SettingsViewModel.cs","line":13,"tags":["module-boundary","coupling","service-discovery"],"confidence":0.93,"created_at":"2026-01-19T15:09:46+08:00","updated_at":"2026-01-24T07:03:11.533Z","bound_solution_id":"SOL-DSC-20260119-150946-006-p3x8","planned_at":"2026-01-19T16:19:55.473Z","completed_at":"2026-01-24T07:03:11.532Z"}
{"id":"DSC-20260119-150946-007","discovery_id":"DSC-20260119-150946","title":"Dual configuration systems: appsettings.json and database","type":"refactor","priority":"high","status":"completed","perspectives":["maintainability"],"category":"interface-design","description":"System uses both appsettings.json and ApplicationSettings database table with unclear boundaries, leading to confusion and potential synchronization issues.","file":"XhMonitor.Service/Data/MonitorDbContext.cs","line":85,"tags":["interface-design","configuration","architecture"],"confidence":0.88,"created_at":"2026-01-19T15:09:46+08:00","updated_at":"2026-01-24T07:03:12.274Z","bound_solution_id":"SOL-DSC-20260119-150946-007-r9b5","planned_at":"2026-01-19T16:19:58.306Z","completed_at":"2026-01-24T07:03:12.273Z"}
{"id":"DSC-20260119-150946-008","discovery_id":"DSC-20260119-150946","title":"Fake Asynchrony - Sync-over-Async Wrapper","type":"refactor","priority":"high","status":"completed","perspectives":["best-practices"],"category":"anti-pattern","description":"Wrapping fast synchronous P/Invoke calls in Task.Run introduces thread pool overhead without scalability benefits. This is 'fake async' that degrades throughput under load.","file":"XhMonitor.Core/Providers/SystemMetricProvider.cs","line":149,"tags":["best-practices","performance","async"],"confidence":0.95,"created_at":"2026-01-19T15:09:46+08:00","updated_at":"2026-01-24T07:03:13.140Z","bound_solution_id":"SOL-DSC-20260119-150946-008-k7m2","planned_at":"2026-01-19T16:20:48.147Z","completed_at":"2026-01-24T07:03:13.139Z"}
{"id":"DSC-20260119-150946-009","discovery_id":"DSC-20260119-150946","title":"Weakly-Typed SignalR Hub - Magic Strings","type":"refactor","priority":"high","status":"completed","perspectives":["best-practices"],"category":"framework-usage","description":"Using IHubContext with SendAsync and magic strings relies on runtime string matching. Error-prone, hard to refactor, lacks compile-time safety.","file":"XhMonitor.Service/Worker.cs","line":17,"tags":["best-practices","signalr","type-safety"],"confidence":0.98,"created_at":"2026-01-19T15:09:46+08:00","updated_at":"2026-01-24T07:03:13.905Z","bound_solution_id":"SOL-DSC-20260119-150946-009-p3x8","planned_at":"2026-01-19T16:19:41.040Z","completed_at":"2026-01-24T07:03:13.904Z"}
{"id":"DSC-20260119-150946-010","discovery_id":"DSC-20260119-150946","title":"Blocking Async Operations - .Result and .Wait() Usage","type":"bug","priority":"high","status":"completed","perspectives":["best-practices"],"category":"anti-pattern","description":"Multiple instances of blocking async operations using .Result, .Wait(), and .GetAwaiter().GetResult(). Can cause deadlocks in UI contexts.","file":"XhMonitor.Desktop/FloatingWindow.xaml.cs","line":716,"tags":["best-practices","async","deadlock-risk"],"confidence":0.92,"created_at":"2026-01-19T15:09:46+08:00","updated_at":"2026-01-24T07:03:14.661Z","bound_solution_id":"SOL-DSC-20260119-150946-010-p3n8","planned_at":"2026-01-19T16:20:50.883Z","completed_at":"2026-01-24T07:03:14.660Z"}
{"id":"DSC-20260119-150946-011","discovery_id":"DSC-20260119-150946","title":"HttpClient Instance Per Request - Socket Exhaustion Risk","type":"bug","priority":"high","status":"completed","perspectives":["best-practices"],"category":"anti-pattern","description":"Creating new HttpClient() in constructor violates best practices. Should be reused or created via IHttpClientFactory to avoid socket exhaustion.","file":"XhMonitor.Desktop/ViewModels/SettingsViewModel.cs","line":35,"tags":["best-practices","httpclient","resource-management"],"confidence":0.95,"created_at":"2026-01-19T15:09:46+08:00","updated_at":"2026-01-24T07:03:15.442Z","bound_solution_id":"SOL-DSC-20260119-150946-011-k7m2","planned_at":"2026-01-19T16:19:38.317Z","completed_at":"2026-01-24T07:03:15.441Z"}
{"id":"ISS-1769239097521-0","title":"Remove fake async wrappers from SystemMetricProvider","status":"completed","priority":2,"context":"Wrapping fast, synchronous P/Invoke calls (GlobalMemoryStatusEx) in Task.Run introduces thread pool overhead without scalability benefits. This is 'fake async' that shifts CPU-bound work to the thread pool unnecessarily, degrading throughput under load. The operation is fast enough that async wrapping provides no benefit.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-001-a1f8c2d4","perspective":"best-practices","file":"XhMonitor.Core/Providers/SystemMetricProvider.cs","line":149,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:20:13.965Z","completed_at":"2026-01-24T07:20:13.964Z"}
{"id":"ISS-1769239097521-1","title":"Implement strongly-typed SignalR hub interface","status":"completed","priority":2,"context":"Using IHubContext<T> with SendAsync and magic strings (SignalREvents.HardwareLimits) relies on runtime string matching. This is error-prone, hard to refactor, and lacks compile-time safety. SignalR best practices recommend strongly-typed hubs for type safety and refactoring support.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-002-b2e9d3f5","perspective":"best-practices","file":"XhMonitor.Service/Worker.cs","line":17,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:20:14.707Z","completed_at":"2026-01-24T07:20:14.707Z"}
{"id":"ISS-1769239097521-6","title":"Remove blocking async calls to prevent deadlocks","status":"completed","priority":2,"context":"Multiple instances of blocking async operations using .Result, .Wait(), and .GetAwaiter().GetResult() found. This can cause deadlocks in UI contexts and defeats the purpose of async/await. Found in FloatingWindow.xaml.cs:716, App.xaml.cs:540, App.xaml.cs:651, and SystemMetricProvider.cs:94-142.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-007-a7d4c8e0","perspective":"best-practices","file":"XhMonitor.Desktop/FloatingWindow.xaml.cs","line":716,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:20:15.473Z","completed_at":"2026-01-24T07:20:15.472Z"}
{"id":"ISS-1769239097521-7","title":"Use IHttpClientFactory for HttpClient management","status":"completed","priority":2,"context":"Creating new HttpClient() in SettingsViewModel constructor violates HttpClient best practices. HttpClient should be reused or created via IHttpClientFactory to avoid socket exhaustion. Each instance holds connections that aren't released immediately.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-best-practices-008-b8e5d9f1","perspective":"best-practices","file":"XhMonitor.Desktop/ViewModels/SettingsViewModel.cs","line":35,"labels":["best-practices"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:20:16.210Z","completed_at":"2026-01-24T07:20:16.210Z"}
{"id":"ISS-1769239097521-12","title":"Extract ISystemMetricProvider interface from SystemMetricProvider","status":"completed","priority":2,"context":"Worker class directly injects the concrete SystemMetricProvider class instead of an interface (e.g., ISystemMetricService). This tight coupling makes it impossible to mock system metrics for unit testing and couples the Service layer to Core implementation details, violating the dependency inversion principle.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-001-a1b2c3d4","perspective":"maintainability","file":"XhMonitor.Service/Worker.cs","line":33,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:20:16.951Z","completed_at":"2026-01-24T07:20:16.951Z"}
{"id":"ISS-1769239097521-16","title":"Refactor IMetricProvider to include detailed metrics method","status":"completed","priority":2,"context":"SystemMetricProvider uses 'is' type checking to cast generic IMetricProvider to concrete types (LibreHardwareMonitorVramProvider, VramMetricProvider) to access specific methods not in the interface. Adding a new provider requires modifying this class, violating the Open/Closed Principle.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-007-a7b8c9d0","perspective":"maintainability","file":"XhMonitor.Core/Providers/SystemMetricProvider.cs","line":179,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:20:17.706Z","completed_at":"2026-01-24T07:20:17.705Z"}
{"id":"ISS-1769239097521-19","title":"Desktop should discover Service endpoint dynamically","status":"completed","priority":2,"context":"Desktop module hardcodes the Service API endpoint (localhost:35179) in SettingsViewModel and App.xaml.cs. This creates a tight coupling between modules and prevents independent deployment or configuration. Changes to Service port require updating Desktop code.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-010-d0e1f2a3","perspective":"maintainability","file":"XhMonitor.Desktop/ViewModels/SettingsViewModel.cs","line":13,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:20:18.451Z","completed_at":"2026-01-24T07:20:18.450Z"}
{"id":"ISS-1769239097521-22","title":"Clarify configuration system boundaries and synchronization","status":"completed","priority":2,"context":"The system uses two parallel configuration systems: appsettings.json for Service configuration and ApplicationSettings database table for user preferences. The boundary between these systems is unclear, leading to confusion about where to store new settings and potential synchronization issues.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-013-a3b4c5d6","perspective":"maintainability","file":"XhMonitor.Service/Data/MonitorDbContext.cs","line":85,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:20:19.212Z","completed_at":"2026-01-24T07:20:19.211Z"}
{"id":"ISS-1769239097521-18","title":"Establish single source of truth for configuration","status":"completed","priority":2,"context":"Configuration is scattered across multiple locations: appsettings.json (Service), database ApplicationSettings table, hardcoded defaults in SettingsViewModel, and hardcoded values in App.xaml.cs. This creates inconsistency, makes it difficult to understand the source of truth, and increases maintenance burden.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-009-c9d0e1f2","perspective":"maintainability","file":"XhMonitor.Desktop/ViewModels/SettingsViewModel.cs","line":13,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:20:19.952Z","completed_at":"2026-01-24T07:20:19.951Z"}
{"id":"ISS-1769239097521-20","title":"Centralize default configuration values","status":"completed","priority":3,"context":"Default values for settings are defined in multiple places with potential inconsistencies: appsettings.json (IntervalSeconds: 3), SettingsViewModel (_processInterval: 5000), database seed (SystemInterval: 1000), and RestoreDefaults method. This creates confusion about the actual defaults and maintenance burden.","source":"discovery","source_discovery_id":"DSC-20260119-150946","source_finding_id":"dsc-maintainability-011-e1f2a3b4","perspective":"maintainability","file":"XhMonitor.Desktop/Windows/SettingsWindow.xaml.cs","line":56,"labels":["maintainability"],"created_at":"2026-01-24T07:18:17.521Z","updated_at":"2026-01-24T07:20:20.725Z","completed_at":"2026-01-24T07:20:20.724Z"}
{"id":"ISS-20260125-001","title":"进程详情卡片未随主悬浮窗拖动而移动","status":"completed","priority":2,"context":"**问题描述**：\n鼠标点击监控悬浮窗后，弹出的进程详情卡片（DetailsPopup）未随着主悬浮窗位置拖动而移动，卡片定在原地，会遮挡监控悬浮窗。\n\n**期望行为**：\n进程详情卡片应该跟随监控悬浮窗移动，保持相对位置不变。\n\n**当前行为**：\n- 点击悬浮窗后，DetailsPopup 弹出\n- 拖动悬浮窗时，DetailsPopup 停留在原位置\n- DetailsPopup 会遮挡移动后的悬浮窗\n\n**受影响组件**：\n- XhMonitor.Desktop/FloatingWindow.xaml.cs (Popup 定位逻辑)\n- XhMonitor.Desktop/FloatingWindow.xaml (DetailsPopup 定义，line 393-395)\n- XhMonitor.Desktop/ViewModels/FloatingWindowViewModel.cs (IsDetailsVisible 属性)\n\n**技术细节**：\n- DetailsPopup 使用 WPF Popup 控件，PlacementTarget 绑定到 MonitorBar\n- Popup.Placement 设置为 Custom，使用 OnCustomPopupPlacement 回调计算位置\n- WPF Popup 默认不会随父窗口拖动自动更新位置\n- 需要监听窗口 LocationChanged 事件，手动更新 Popup 位置或使用 Popup.HorizontalOffset/VerticalOffset 强制重新计算","source":"text","expected_behavior":"进程详情卡片跟随监控悬浮窗移动，保持相对位置不变","actual_behavior":"卡片停留在原位置，会遮挡移动后的悬浮窗","affected_components":["XhMonitor.Desktop/FloatingWindow.xaml.cs","XhMonitor.Desktop/FloatingWindow.xaml","XhMonitor.Desktop/ViewModels/FloatingWindowViewModel.cs"],"bound_solution_id":"SOL-ISS-20260125-001-y6d1","created_at":"2026-01-25T10:35:34.493Z","updated_at":"2026-01-25T15:21:47.069Z","planned_at":"2026-01-25T11:21:38.887Z","queued_at":"2026-01-25T15:11:21.202Z","completed_at":"2026-01-25T15:21:47.068Z"}
{"id":"ISS-20260127-004","title":"FloatingWindow.xaml 使用未定义的 BoolToVisibility 资源","status":"completed","priority":2,"context":"在 FloatingWindow.xaml (Line 307) 中使用了 Converter={StaticResource BoolToVisibility}，但在 Diff 中未看到该资源的定义（可能在 App.xaml 中）。如果资源未定义，会导致运行时 XAML 绑定错误。","source":"text","expected_behavior":"确保 BooleanToVisibilityConverter 已在 App.xaml 或当前窗口的资源字典中定义","actual_behavior":"XAML 中引用了 BoolToVisibility 资源，但定义位置不明确，可能导致运行时错误","affected_components":["XhMonitor.Desktop/FloatingWindow.xaml","XhMonitor.Desktop/App.xaml"],"bound_solution_id":"SOL-ISS-20260127-004-v3n8","created_at":"2026-01-27T02:44:36.506Z","updated_at":"2026-01-27T03:05:23.272Z","planned_at":"2026-01-27T02:56:10.840Z","queued_at":"2026-01-27T03:01:44.852Z","completed_at":"2026-01-27T03:05:23.271Z"}
{"id":"ISS-20260127-001","title":"HttpClient 频繁实例化导致资源管理问题","status":"completed","priority":3,"context":"在 SettingsWindow.xaml.cs (Line 36, 57) 和 FloatingWindow.xaml.cs (Line 248) 中使用 new System.Net.Http.HttpClient() 频繁实例化。虽然在桌面应用中频率不高，但这不是最佳实践，且未处理连接池。","source":"text","expected_behavior":"在 ServiceCollection 中注册单例 HttpClient 或使用 IHttpClientFactory，并通过构造函数注入使用","actual_behavior":"在方法内部直接 new HttpClient()，可能导致端口耗尽和连接池问题","affected_components":["XhMonitor.Desktop/SettingsWindow.xaml.cs","XhMonitor.Desktop/FloatingWindow.xaml.cs"],"bound_solution_id":"SOL-ISS-20260127-001-h7k2","created_at":"2026-01-27T02:44:31.667Z","updated_at":"2026-01-27T03:09:11.123Z","planned_at":"2026-01-27T02:56:07.993Z","queued_at":"2026-01-27T03:01:44.852Z","completed_at":"2026-01-27T03:09:11.123Z"}
{"id":"ISS-20260127-003","title":"MonitorDbContext Seed Data 使用硬编码 ID 存在冲突风险","status":"completed","priority":3,"context":"在 MonitorDbContext.cs (Line 89-95) 中，Seed Data 使用了硬编码的 ID (9-15): new ApplicationSettings { Id = 9 ... }。这种方式在多人协作或现有数据库存在数据偏差时可能导致主键冲突。","source":"text","expected_behavior":"使用自动递增 ID 或检查现有数据后动态分配 ID，避免硬编码","actual_behavior":"Seed Data 使用固定 ID 值 (9-15)，可能与现有数据冲突","affected_components":["XhMonitor.Server/Data/MonitorDbContext.cs"],"bound_solution_id":"SOL-ISS-20260127-003-k8m2","created_at":"2026-01-27T02:44:34.903Z","updated_at":"2026-01-27T03:09:11.984Z","planned_at":"2026-01-27T02:57:10.213Z","queued_at":"2026-01-27T03:01:44.852Z","completed_at":"2026-01-27T03:09:11.984Z"}
{"id":"ISS-20260127-005","title":"SettingsViewModel 使用魔法字符串访问配置字典","status":"completed","priority":4,"context":"在 SettingsViewModel.cs (Line 165-173) 中，使用了大量魔法字符串 (\"MonitorCpu\", \"Monitoring\") 来访问字典: monitoring[\"MonitorCpu\"]。这种方式容易出现拼写错误，且难以重构。","source":"text","expected_behavior":"使用 ConfigurationDefaults.Monitoring 中定义的常量或者 nameof() 操作符来获取键名，保持强类型引用","actual_behavior":"直接使用字符串字面量访问字典，缺乏类型安全","affected_components":["XhMonitor.Desktop/ViewModels/SettingsViewModel.cs"],"bound_solution_id":"SOL-ISS-20260127-005-p3v7","created_at":"2026-01-27T02:44:38.132Z","updated_at":"2026-01-27T03:09:12.857Z","planned_at":"2026-01-27T02:57:11.866Z","queued_at":"2026-01-27T03:01:44.852Z","completed_at":"2026-01-27T03:09:12.857Z"}
{"id":"ISS-20260127-002","title":"Save_Click 中重复 API 请求影响性能","status":"completed","priority":4,"context":"在 SettingsWindow.xaml.cs (Line 57) 的 Save_Click 方法中，为了对比管理员模式状态，重新请求了一次 API: GetAsync($\"{_viewModel.GetApiBaseUrl()}/settings\")。这会增加不必要的网络开销。","source":"text","expected_behavior":"在 SettingsViewModel 初始化加载数据时，保留一份 _originalAdminMode 副本。保存时直接对比 AdminMode 和 _originalAdminMode","actual_behavior":"每次保存时都重新请求 API 获取原始状态进行对比","affected_components":["XhMonitor.Desktop/SettingsWindow.xaml.cs","XhMonitor.Desktop/ViewModels/SettingsViewModel.cs"],"bound_solution_id":"SOL-ISS-20260127-002-m4p9","created_at":"2026-01-27T02:44:33.285Z","updated_at":"2026-01-27T03:12:16.197Z","planned_at":"2026-01-27T02:56:09.438Z","queued_at":"2026-01-27T03:01:44.852Z","completed_at":"2026-01-27T03:12:16.197Z"}
{"id":"ISS-20260127-006","title":"StartupManager 和 AdminModeManager 静态类难以单元测试","status":"completed","priority":3,"context":"StartupManager.cs 和 AdminModeManager.cs 都是 public static class，这种设计难以编写单元测试，因为无法 Mock 注册表和进程操作。","source":"text","expected_behavior":"提取为接口（如 IStartupManager, IAdminModeManager），并使用依赖注入。这样可以在测试中 Mock 注册表和进程操作","actual_behavior":"使用静态类实现，无法进行依赖注入和单元测试","affected_components":["XhMonitor.Desktop/Utils/StartupManager.cs","XhMonitor.Desktop/Utils/AdminModeManager.cs"],"bound_solution_id":"SOL-ISS-20260127-006-r9n4","created_at":"2026-01-27T02:44:39.852Z","updated_at":"2026-01-27T03:18:58.947Z","planned_at":"2026-01-27T02:57:13.376Z","queued_at":"2026-01-27T03:01:44.852Z","completed_at":"2026-01-27T03:18:58.946Z"}
