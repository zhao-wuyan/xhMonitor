{
  "summary": "修复 GPU 占用监控不准确的问题，包括两个核心缺陷：(1) PerformanceCounter 首次调用返回 0 的预热问题，(2) GPU Engine 使用率错误累加导致数值偏离实际。修复策略采用综合修复方案，确保数据采集准确性和聚合逻辑正确性。",
  "root_cause": "GPU 监控不准确由两个根本原因导致：(1) Performance 角度：GpuMetricProvider.GetSystemTotalAsync() 在初始化性能计数器后立即调用 NextValue()，违反了 PerformanceCounter 的使用约定（第一次调用总是返回 0，需要两次调用之间有时间间隔）。WarmupAsync 方法只创建了计数器实例但未执行预热调用，未能解决核心问题。(2) Dataflow 角度：GetSystemTotalAsync() 错误地直接累加所有 GPU Engine 实例的使用率。Windows 性能计数器返回的是每个引擎（3D、Copy、Video Decode 等）的独立使用率（0-100%），应该取最大值，而非简单累加，否则会导致总使用率严重偏离实际值（可能超过 100%）。",
  "strategy": "comprehensive_fix",
  "tasks": [
    {
      "id": "FIX1",
      "title": "修正 GPU 性能计数器预热逻辑",
      "scope": "XhMonitor.Core/Providers/",
      "action": "Fix",
      "description": "在 GpuMetricProvider.WarmupAsync 方法中，创建性能计数器实例后立即执行一次预热调用（NextValue()），忽略返回值 0，确保后续采集能获取有效数据。",
      "modification_points": [
        {
          "file": "XhMonitor.Core/Providers/GpuMetricProvider.cs",
          "target": "WarmupAsync:50-60",
          "change": "在 _systemCountersInitialized = true 之前，遍历 _systemCounters 并调用一次 NextValue() 进行预热"
        }
      ],
      "implementation": [
        "定位 GpuMetricProvider.WarmupAsync 方法中的系统计数器初始化循环（约 L:50-60）",
        "在设置 _systemCountersInitialized = true 之前，添加预热循环：foreach (var counter in _systemCounters) { try { counter.NextValue(); } catch { } }",
        "确保预热调用在所有计数器创建完成后、标志位设置前执行",
        "保持现有的异常处理逻辑，预热失败不影响服务启动"
      ],
      "verification": [
        "启动 XhMonitor.Service，观察控制台日志中的第一条 System usage 日志",
        "验证首次采集的 GPU 使用率不再是 0%，而是反映实际负载",
        "在 GPU 高负载场景下（如运行游戏），确认首次数据准确"
      ],
      "risk": "low"
    },
    {
      "id": "FIX2",
      "title": "修正 GPU 使用率聚合逻辑",
      "scope": "XhMonitor.Core/Providers/",
      "action": "Fix",
      "description": "将 GpuMetricProvider.GetSystemTotalAsync() 中的简单累加逻辑改为取所有 GPU Engine 实例的最大值，符合用户选择的聚合策略（取所有引擎的最大值）。",
      "modification_points": [
        {
          "file": "XhMonitor.Core/Providers/GpuMetricProvider.cs",
          "target": "GetSystemTotalAsync:62-73",
          "change": "将 totalUtilization += counter.NextValue() 改为 maxUtilization = Math.Max(maxUtilization, counter.NextValue())"
        }
      ],
      "implementation": [
        "定位 GpuMetricProvider.GetSystemTotalAsync 方法（L:62-73）",
        "将累加逻辑（totalUtilization += value）改为取最大值逻辑（maxUtilization = Math.Max(maxUtilization, value)）",
        "初始化 maxUtilization = 0，遍历所有 _systemCounters 并更新最大值",
        "返回 Math.Round(maxUtilization, 1) 作为系统总 GPU 使用率"
      ],
      "verification": [
        "启动 XhMonitor.Service，观察控制台日志中的 GPU 使用率",
        "对比任务管理器中的 GPU 使用率，验证数值接近（误差 <5%）",
        "在多引擎负载场景下（如同时运行 3D 游戏和视频解码），确认使用率不超过 100%"
      ],
      "risk": "low"
    },
    {
      "id": "FIX3",
      "title": "添加控制台日志输出系统占用情况",
      "scope": "XhMonitor.Service/",
      "action": "Add",
      "description": "在 Worker.cs 的系统监控循环中添加详细的控制台日志输出，包括 CPU、GPU、Memory、VRAM 的当前占用情况，方便用户分析监控数据准确性。",
      "modification_points": [
        {
          "file": "XhMonitor.Service/Worker.cs",
          "target": "RunSystemUsageLoopAsync:采集数据后",
          "change": "在数据采集后添加 Console.WriteLine 输出系统占用详情"
        }
      ],
      "implementation": [
        "定位 Worker.cs 的 RunSystemUsageLoopAsync 方法中的数据采集逻辑",
        "在 SystemMetricProvider.GetSystemUsageAsync() 调用后，添加 Console.WriteLine 输出",
        "输出格式：Console.WriteLine($\"[{DateTime.Now:HH:mm:ss}] System Usage - CPU: {usage.TotalCpu:F1}%, GPU: {usage.TotalGpu:F1}%, Memory: {usage.TotalMemory}MB, VRAM: {usage.TotalVram}MB\");",
        "确保日志输出在 Serilog 日志之外，直接输出到控制台"
      ],
      "verification": [
        "启动 XhMonitor.Service，观察控制台是否输出系统占用日志",
        "验证日志格式清晰，包含时间戳和所有关键指标",
        "确认日志输出频率与采集间隔一致（默认 1 秒）"
      ],
      "risk": "low"
    }
  ],
  "focus_paths": [
    "XhMonitor.Core/Providers/GpuMetricProvider.cs",
    "XhMonitor.Service/Worker.cs"
  ],
  "test_strategy": {
    "scope": "smoke",
    "manual_verification": [
      "启动服务，观察控制台日志中的首次 GPU 数据是否准确（不为 0%）",
      "对比任务管理器中的 GPU 使用率，验证数值接近（误差 <5%）",
      "在高负载场景下（运行游戏、视频渲染），确认 GPU 使用率不超过 100%",
      "验证控制台日志输出格式正确，包含所有系统占用指标"
    ]
  },
  "estimated_time": "30 minutes",
  "recommended_execution": "Agent",
  "severity": "Medium",
  "risk_level": "low",
  "_metadata": {
    "timestamp": "2026-01-12T08:00:00Z",
    "source": "direct-planning",
    "planning_mode": "direct",
    "diagnosis_angles": ["performance", "dataflow"]
  }
}