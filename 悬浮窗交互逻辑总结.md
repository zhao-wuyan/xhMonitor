# 悬浮窗交互逻辑总结

## 架构概览

悬浮窗系统采用 **前后端分离 + SignalR 实时通信** 架构：

```
后端服务 (Worker)
    ↓ SignalR Hub
WPF 窗口 (FloatingWindow) ← WebView2 → React 前端 (FloatingWidget)
```

---

## 一、前端交互逻辑 (FloatingWidget.tsx)

### 1.1 状态机设计

悬浮窗有 **4 种状态**：

| 状态 | 说明 | 触发条件 |
|------|------|----------|
| `collapsed` | 收起状态，仅显示简要信息 | 默认状态，鼠标移出时 |
| `expanded` | 展开状态，显示详细信息 | 鼠标悬停时 |
| `locked` | 锁定展开状态 | 在 expanded 状态下点击背景 |
| `clickthrough` | 穿透模式，窗口不响应鼠标事件 | 在 locked 状态下点击穿透按钮 |

**状态转换规则**：
```
collapsed ←→ expanded (hover 触发)
expanded → locked (点击背景)
locked → collapsed (再次点击背景)
locked ↔ clickthrough (点击穿透按钮)
```

### 1.2 交互事件

#### 1.2.1 背景点击 (handleBackgroundClick)
- **触发条件**：点击背景区域（非内容区域）
- **行为**：
  - `expanded` → `locked`：锁定展开状态
  - `locked` → `collapsed`：解锁并收起

#### 1.2.2 指标点击 (handleMetricClick)
- **触发条件**：点击 CPU/Memory/GPU/VRAM 指标卡片
- **前置检查**：通过 `isMetricClickEnabled()` 检查是否启用
- **行为**：
  ```javascript
  window.chrome.webview.postMessage({
    type: 'metricAction',
    metricId: 'cpu' | 'memory' | 'gpu' | 'vram',
    action: getMetricAction(metricId)  // 从配置获取动作
  });
  ```

#### 1.2.3 进程点击 (handleProcessClick)
- **触发条件**：点击进程列表中的进程项
- **行为**：
  ```javascript
  window.chrome.webview.postMessage({
    type: 'processAction',
    processId: number,
    processName: string,
    action: 'showDetails'
  });
  ```

#### 1.2.4 穿透模式切换 (handleToggleClickthrough)
- **触发条件**：点击穿透按钮（仅在 locked 或 clickthrough 状态下显示）
- **行为**：
  ```javascript
  window.chrome.webview.postMessage({
    type: 'setClickthrough',
    enabled: true | false
  });
  ```

### 1.3 数据展示

#### 系统摘要
- **数据源**：`calculateSystemSummary(metricsData.processes)`
- **计算逻辑**：汇总所有进程的 CPU/Memory/GPU/VRAM 占用

#### Top 5 进程
- **排序规则**：按 CPU 占用降序
- **数据更新**：通过 `useMemo` 自动响应 `metricsData` 变化

---

## 二、WPF 窗口逻辑 (FloatingWindow.xaml.cs)

### 2.1 窗口特性

#### 2.1.1 位置持久化
- **存储**：通过 `WindowPositionStore` 保存窗口位置
- **恢复**：在 `OnSourceInitialized` 时加载上次位置

#### 2.1.2 点击穿透 (SetClickThrough)
- **实现原理**：设置 `WS_EX_TRANSPARENT` 窗口样式
- **启用时**：
  - 窗口不响应鼠标事件
  - 注册热键 `Ctrl+Shift+Esc` 用于退出穿透模式
- **禁用时**：
  - 恢复正常交互
  - 注销热键

#### 2.1.3 热键处理 (WndProc)
- **监听消息**：`WM_HOTKEY (0x0312)`
- **行为**：按下 `Ctrl+Shift+Esc` 时退出穿透模式

### 2.2 事件对外暴露

```csharp
public event EventHandler<MetricActionEventArgs>? MetricActionRequested;
public event EventHandler<ProcessActionEventArgs>? ProcessActionRequested;
```

这些事件由主应用程序订阅，用于响应前端的交互请求。

---

## 三、数据流 (ViewModel + SignalR)

### 3.1 数据采集与推送

```
Worker (后端服务)
  ↓ 定期采集指标 (每 N 秒)
  ↓ SaveMetricsAsync (存储到数据库)
  ↓ SignalR Hub.Clients.All.SendAsync("metrics.latest", data)
  ↓
SignalRService (桌面端)
  ↓ 监听 "metrics.latest" 事件
  ↓ 反序列化为 MetricsDataDto
  ↓ 触发 MetricsReceived 事件
  ↓
FloatingWindowViewModel
  ↓ 计算 TotalCpu, TotalMemory, TotalGpu, TotalVram
  ↓ 筛选 Top 5 进程
  ↓ 更新 ObservableCollection<ProcessInfoDto>
  ↓
WPF 数据绑定 → UI 自动更新
```

### 3.2 连接状态管理

- **连接事件**：`SignalRService.ConnectionStateChanged`
- **自动重连**：通过 `.WithAutomaticReconnect()` 实现
- **UI 指示**：右上角圆点（绿色=已连接，红色=断开）

---

## 四、关键技术点

### 4.1 前后端通信
- **方向**：React → WPF
- **机制**：`window.chrome.webview.postMessage()`
- **消息类型**：
  - `metricAction`：指标点击
  - `processAction`：进程点击
  - `setClickthrough`：穿透模式切换

### 4.2 实时数据同步
- **协议**：SignalR (WebSocket)
- **频率**：由后端 Worker 的采集周期决定
- **数据格式**：
  ```json
  {
    "Timestamp": "2025-12-23T10:00:00Z",
    "ProcessCount": 50,
    "Processes": [
      {
        "ProcessId": 1234,
        "ProcessName": "chrome.exe",
        "CommandLine": "...",
        "Metrics": {
          "cpu": { "Value": 15.5 },
          "memory": { "Value": 512000000 }
        }
      }
    ]
  }
  ```

### 4.3 性能优化
- **useMemo**：缓存计算结果（系统摘要、Top 5 进程）
- **事件防抖**：状态转换通过 `useEffect` 控制
- **Dispatcher.Invoke**：确保 UI 更新在主线程执行

---

## 五、配置系统

### 5.1 指标配置 (useMetricConfig)
- **作用**：控制哪些指标可点击
- **方法**：
  - `isMetricClickEnabled(metricId)`：检查是否启用
  - `getMetricAction(metricId)`：获取点击动作

### 5.2 窗口配置 (useWidgetConfig)
- **作用**：管理悬浮窗行为配置
- **存储**：可能通过本地存储或配置文件

---

## 六、异常处理

### 6.1 连接失败
- **场景**：后端服务未启动
- **处理**：
  - 显示警告对话框
  - 连接状态指示器变红
  - 自动重连机制

### 6.2 数据反序列化失败
- **场景**：SignalR 消息格式不匹配
- **处理**：
  - 捕获异常并记录到 Debug 输出
  - 不影响后续数据接收

### 6.3 应用关闭
- **检查**：`Application.Current?.Dispatcher?.HasShutdownStarted`
- **行为**：如果应用正在关闭，跳过 UI 更新

---

## 七、待优化点

1. **状态持久化**：当前 `locked` 和 `clickthrough` 状态在重启后丢失
2. **错误提示**：连接失败时的用户体验可以改进（如重试按钮）
3. **性能监控**：可添加 SignalR 消息延迟监控
4. **配置界面**：指标点击动作的配置目前可能需要手动编辑配置文件
